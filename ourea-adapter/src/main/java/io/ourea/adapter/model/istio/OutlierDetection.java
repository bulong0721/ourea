// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: destination_rule.proto

package io.ourea.adapter.model.istio;

/**
 * <pre>
 * A Circuit breaker implementation that tracks the status of each
 * individual host in the upstream service.  Applicable to both HTTP and
 * TCP services.  For HTTP services, hosts that continually return 5xx
 * errors for API calls are ejected from the pool for a pre-defined period
 * of time. For TCP services, connection timeouts or connection
 * failures to a given host counts as an error when measuring the
 * consecutive errors metric. See Envoy's [outlier
 * detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier)
 * for more details.
 * The following rule sets a connection pool size of 100 HTTP1 connections
 * with no more than 10 req/connection to the "reviews" service. In addition,
 * it sets a limit of 1000 concurrent HTTP2 requests and configures upstream
 * hosts to be scanned every 5 mins so that any host that fails 7 consecutive
 * times with a 502, 503, or 504 error code will be ejected for 15 minutes.
 * {{&lt;tabset category-name="example"&gt;}}
 * {{&lt;tab name="v1alpha3" category-value="v1alpha3"&gt;}}
 * ```yaml
 * apiVersion: networking.istio.io/v1alpha3
 * kind: DestinationRule
 * metadata:
 *   name: reviews-cb-policy
 * spec:
 *   host: reviews.prod.svc.cluster.local
 *   trafficPolicy:
 *     connectionPool:
 *       tcp:
 *         maxConnections: 100
 *       http:
 *         http2MaxRequests: 1000
 *         maxRequestsPerConnection: 10
 *     outlierDetection:
 *       consecutiveErrors: 7
 *       interval: 5m
 *       baseEjectionTime: 15m
 * ```
 * {{&lt;/tab&gt;}}
 * {{&lt;tab name="v1beta1" category-value="v1beta1"&gt;}}
 * ```yaml
 * apiVersion: networking.istio.io/v1beta1
 * kind: DestinationRule
 * metadata:
 *   name: reviews-cb-policy
 * spec:
 *   host: reviews.prod.svc.cluster.local
 *   trafficPolicy:
 *     connectionPool:
 *       tcp:
 *         maxConnections: 100
 *       http:
 *         http2MaxRequests: 1000
 *         maxRequestsPerConnection: 10
 *     outlierDetection:
 *       consecutiveErrors: 7
 *       interval: 5m
 *       baseEjectionTime: 15m
 * ```
 * {{&lt;/tab&gt;}}
 * {{&lt;/tabset&gt;}}
 * </pre>
 *
 * Protobuf type {@code istio.networking.v1alpha3.OutlierDetection}
 */
public final class OutlierDetection extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:istio.networking.v1alpha3.OutlierDetection)
    OutlierDetectionOrBuilder {
private static final long serialVersionUID = 0L;
  // Use OutlierDetection.newBuilder() to construct.
  private OutlierDetection(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private OutlierDetection() {
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new OutlierDetection();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private OutlierDetection(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {

            consecutiveErrors_ = input.readInt32();
            break;
          }
          case 18: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (interval_ != null) {
              subBuilder = interval_.toBuilder();
            }
            interval_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(interval_);
              interval_ = subBuilder.buildPartial();
            }

            break;
          }
          case 26: {
            com.google.protobuf.Duration.Builder subBuilder = null;
            if (baseEjectionTime_ != null) {
              subBuilder = baseEjectionTime_.toBuilder();
            }
            baseEjectionTime_ = input.readMessage(com.google.protobuf.Duration.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(baseEjectionTime_);
              baseEjectionTime_ = subBuilder.buildPartial();
            }

            break;
          }
          case 32: {

            maxEjectionPercent_ = input.readInt32();
            break;
          }
          case 40: {

            minHealthPercent_ = input.readInt32();
            break;
          }
          case 50: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (consecutiveGatewayErrors_ != null) {
              subBuilder = consecutiveGatewayErrors_.toBuilder();
            }
            consecutiveGatewayErrors_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(consecutiveGatewayErrors_);
              consecutiveGatewayErrors_ = subBuilder.buildPartial();
            }

            break;
          }
          case 58: {
            com.google.protobuf.UInt32Value.Builder subBuilder = null;
            if (consecutive5XxErrors_ != null) {
              subBuilder = consecutive5XxErrors_.toBuilder();
            }
            consecutive5XxErrors_ = input.readMessage(com.google.protobuf.UInt32Value.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(consecutive5XxErrors_);
              consecutive5XxErrors_ = subBuilder.buildPartial();
            }

            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.ourea.adapter.model.istio.DestinationRuleOuterClass.internal_static_istio_networking_v1alpha3_OutlierDetection_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.ourea.adapter.model.istio.DestinationRuleOuterClass.internal_static_istio_networking_v1alpha3_OutlierDetection_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.ourea.adapter.model.istio.OutlierDetection.class, io.ourea.adapter.model.istio.OutlierDetection.Builder.class);
  }

  public static final int CONSECUTIVE_ERRORS_FIELD_NUMBER = 1;
  private int consecutiveErrors_;
  /**
   * <pre>
   * Number of errors before a host is ejected from the connection
   * pool. Defaults to 5. When the upstream host is accessed over HTTP, a
   * 502, 503, or 504 return code qualifies as an error. When the upstream host
   * is accessed over an opaque TCP connection, connect timeouts and
   * connection error/failure events qualify as an error.
   * $hide_from_docs
   * </pre>
   *
   * <code>int32 consecutive_errors = 1 [deprecated = true];</code>
   * @return The consecutiveErrors.
   */
  @java.lang.Override
  @java.lang.Deprecated public int getConsecutiveErrors() {
    return consecutiveErrors_;
  }

  public static final int CONSECUTIVE_GATEWAY_ERRORS_FIELD_NUMBER = 6;
  private com.google.protobuf.UInt32Value consecutiveGatewayErrors_;
  /**
   * <pre>
   * Number of gateway errors before a host is ejected from the connection pool.
   * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
   * code qualifies as a gateway error. When the upstream host is accessed over
   * an opaque TCP connection, connect timeouts and connection error/failure
   * events qualify as a gateway error.
   * This feature is disabled by default or when set to the value 0.
   * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
   * used separately or together. Because the errors counted by
   * consecutive_gateway_errors are also included in consecutive_5xx_errors,
   * if the value of consecutive_gateway_errors is greater than or equal to
   * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
   * no effect.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
   * @return Whether the consecutiveGatewayErrors field is set.
   */
  @java.lang.Override
  public boolean hasConsecutiveGatewayErrors() {
    return consecutiveGatewayErrors_ != null;
  }
  /**
   * <pre>
   * Number of gateway errors before a host is ejected from the connection pool.
   * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
   * code qualifies as a gateway error. When the upstream host is accessed over
   * an opaque TCP connection, connect timeouts and connection error/failure
   * events qualify as a gateway error.
   * This feature is disabled by default or when set to the value 0.
   * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
   * used separately or together. Because the errors counted by
   * consecutive_gateway_errors are also included in consecutive_5xx_errors,
   * if the value of consecutive_gateway_errors is greater than or equal to
   * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
   * no effect.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
   * @return The consecutiveGatewayErrors.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getConsecutiveGatewayErrors() {
    return consecutiveGatewayErrors_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : consecutiveGatewayErrors_;
  }
  /**
   * <pre>
   * Number of gateway errors before a host is ejected from the connection pool.
   * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
   * code qualifies as a gateway error. When the upstream host is accessed over
   * an opaque TCP connection, connect timeouts and connection error/failure
   * events qualify as a gateway error.
   * This feature is disabled by default or when set to the value 0.
   * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
   * used separately or together. Because the errors counted by
   * consecutive_gateway_errors are also included in consecutive_5xx_errors,
   * if the value of consecutive_gateway_errors is greater than or equal to
   * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
   * no effect.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getConsecutiveGatewayErrorsOrBuilder() {
    return getConsecutiveGatewayErrors();
  }

  public static final int CONSECUTIVE_5XX_ERRORS_FIELD_NUMBER = 7;
  private com.google.protobuf.UInt32Value consecutive5XxErrors_;
  /**
   * <pre>
   * Number of 5xx errors before a host is ejected from the connection pool.
   * When the upstream host is accessed over an opaque TCP connection, connect
   * timeouts, connection error/failure and request failure events qualify as a
   * 5xx error.
   * This feature defaults to 5 but can be disabled by setting the value to 0.
   * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
   * used separately or together. Because the errors counted by
   * consecutive_gateway_errors are also included in consecutive_5xx_errors,
   * if the value of consecutive_gateway_errors is greater than or equal to
   * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
   * no effect.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
   * @return Whether the consecutive5xxErrors field is set.
   */
  @java.lang.Override
  public boolean hasConsecutive5XxErrors() {
    return consecutive5XxErrors_ != null;
  }
  /**
   * <pre>
   * Number of 5xx errors before a host is ejected from the connection pool.
   * When the upstream host is accessed over an opaque TCP connection, connect
   * timeouts, connection error/failure and request failure events qualify as a
   * 5xx error.
   * This feature defaults to 5 but can be disabled by setting the value to 0.
   * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
   * used separately or together. Because the errors counted by
   * consecutive_gateway_errors are also included in consecutive_5xx_errors,
   * if the value of consecutive_gateway_errors is greater than or equal to
   * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
   * no effect.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
   * @return The consecutive5xxErrors.
   */
  @java.lang.Override
  public com.google.protobuf.UInt32Value getConsecutive5XxErrors() {
    return consecutive5XxErrors_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : consecutive5XxErrors_;
  }
  /**
   * <pre>
   * Number of 5xx errors before a host is ejected from the connection pool.
   * When the upstream host is accessed over an opaque TCP connection, connect
   * timeouts, connection error/failure and request failure events qualify as a
   * 5xx error.
   * This feature defaults to 5 but can be disabled by setting the value to 0.
   * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
   * used separately or together. Because the errors counted by
   * consecutive_gateway_errors are also included in consecutive_5xx_errors,
   * if the value of consecutive_gateway_errors is greater than or equal to
   * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
   * no effect.
   * </pre>
   *
   * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
   */
  @java.lang.Override
  public com.google.protobuf.UInt32ValueOrBuilder getConsecutive5XxErrorsOrBuilder() {
    return getConsecutive5XxErrors();
  }

  public static final int INTERVAL_FIELD_NUMBER = 2;
  private com.google.protobuf.Duration interval_;
  /**
   * <pre>
   * Time interval between ejection sweep analysis. format:
   * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval = 2;</code>
   * @return Whether the interval field is set.
   */
  @java.lang.Override
  public boolean hasInterval() {
    return interval_ != null;
  }
  /**
   * <pre>
   * Time interval between ejection sweep analysis. format:
   * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval = 2;</code>
   * @return The interval.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getInterval() {
    return interval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : interval_;
  }
  /**
   * <pre>
   * Time interval between ejection sweep analysis. format:
   * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
   * </pre>
   *
   * <code>.google.protobuf.Duration interval = 2;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getIntervalOrBuilder() {
    return getInterval();
  }

  public static final int BASE_EJECTION_TIME_FIELD_NUMBER = 3;
  private com.google.protobuf.Duration baseEjectionTime_;
  /**
   * <pre>
   * Minimum ejection duration. A host will remain ejected for a period
   * equal to the product of minimum ejection duration and the number of
   * times the host has been ejected. This technique allows the system to
   * automatically increase the ejection period for unhealthy upstream
   * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
   * </pre>
   *
   * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
   * @return Whether the baseEjectionTime field is set.
   */
  @java.lang.Override
  public boolean hasBaseEjectionTime() {
    return baseEjectionTime_ != null;
  }
  /**
   * <pre>
   * Minimum ejection duration. A host will remain ejected for a period
   * equal to the product of minimum ejection duration and the number of
   * times the host has been ejected. This technique allows the system to
   * automatically increase the ejection period for unhealthy upstream
   * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
   * </pre>
   *
   * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
   * @return The baseEjectionTime.
   */
  @java.lang.Override
  public com.google.protobuf.Duration getBaseEjectionTime() {
    return baseEjectionTime_ == null ? com.google.protobuf.Duration.getDefaultInstance() : baseEjectionTime_;
  }
  /**
   * <pre>
   * Minimum ejection duration. A host will remain ejected for a period
   * equal to the product of minimum ejection duration and the number of
   * times the host has been ejected. This technique allows the system to
   * automatically increase the ejection period for unhealthy upstream
   * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
   * </pre>
   *
   * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
   */
  @java.lang.Override
  public com.google.protobuf.DurationOrBuilder getBaseEjectionTimeOrBuilder() {
    return getBaseEjectionTime();
  }

  public static final int MAX_EJECTION_PERCENT_FIELD_NUMBER = 4;
  private int maxEjectionPercent_;
  /**
   * <pre>
   * Maximum % of hosts in the load balancing pool for the upstream
   * service that can be ejected. Defaults to 10%.
   * </pre>
   *
   * <code>int32 max_ejection_percent = 4;</code>
   * @return The maxEjectionPercent.
   */
  @java.lang.Override
  public int getMaxEjectionPercent() {
    return maxEjectionPercent_;
  }

  public static final int MIN_HEALTH_PERCENT_FIELD_NUMBER = 5;
  private int minHealthPercent_;
  /**
   * <pre>
   * Outlier detection will be enabled as long as the associated load balancing
   * pool has at least min_health_percent hosts in healthy mode. When the
   * percentage of healthy hosts in the load balancing pool drops below this
   * threshold, outlier detection will be disabled and the proxy will load balance
   * across all hosts in the pool (healthy and unhealthy). The threshold can be
   * disabled by setting it to 0%. The default is 0% as it's not typically
   * applicable in k8s environments with few pods per service.
   * </pre>
   *
   * <code>int32 min_health_percent = 5;</code>
   * @return The minHealthPercent.
   */
  @java.lang.Override
  public int getMinHealthPercent() {
    return minHealthPercent_;
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (consecutiveErrors_ != 0) {
      output.writeInt32(1, consecutiveErrors_);
    }
    if (interval_ != null) {
      output.writeMessage(2, getInterval());
    }
    if (baseEjectionTime_ != null) {
      output.writeMessage(3, getBaseEjectionTime());
    }
    if (maxEjectionPercent_ != 0) {
      output.writeInt32(4, maxEjectionPercent_);
    }
    if (minHealthPercent_ != 0) {
      output.writeInt32(5, minHealthPercent_);
    }
    if (consecutiveGatewayErrors_ != null) {
      output.writeMessage(6, getConsecutiveGatewayErrors());
    }
    if (consecutive5XxErrors_ != null) {
      output.writeMessage(7, getConsecutive5XxErrors());
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (consecutiveErrors_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(1, consecutiveErrors_);
    }
    if (interval_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(2, getInterval());
    }
    if (baseEjectionTime_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, getBaseEjectionTime());
    }
    if (maxEjectionPercent_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(4, maxEjectionPercent_);
    }
    if (minHealthPercent_ != 0) {
      size += com.google.protobuf.CodedOutputStream
        .computeInt32Size(5, minHealthPercent_);
    }
    if (consecutiveGatewayErrors_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, getConsecutiveGatewayErrors());
    }
    if (consecutive5XxErrors_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(7, getConsecutive5XxErrors());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.ourea.adapter.model.istio.OutlierDetection)) {
      return super.equals(obj);
    }
    io.ourea.adapter.model.istio.OutlierDetection other = (io.ourea.adapter.model.istio.OutlierDetection) obj;

    if (getConsecutiveErrors()
        != other.getConsecutiveErrors()) return false;
    if (hasConsecutiveGatewayErrors() != other.hasConsecutiveGatewayErrors()) return false;
    if (hasConsecutiveGatewayErrors()) {
      if (!getConsecutiveGatewayErrors()
          .equals(other.getConsecutiveGatewayErrors())) return false;
    }
    if (hasConsecutive5XxErrors() != other.hasConsecutive5XxErrors()) return false;
    if (hasConsecutive5XxErrors()) {
      if (!getConsecutive5XxErrors()
          .equals(other.getConsecutive5XxErrors())) return false;
    }
    if (hasInterval() != other.hasInterval()) return false;
    if (hasInterval()) {
      if (!getInterval()
          .equals(other.getInterval())) return false;
    }
    if (hasBaseEjectionTime() != other.hasBaseEjectionTime()) return false;
    if (hasBaseEjectionTime()) {
      if (!getBaseEjectionTime()
          .equals(other.getBaseEjectionTime())) return false;
    }
    if (getMaxEjectionPercent()
        != other.getMaxEjectionPercent()) return false;
    if (getMinHealthPercent()
        != other.getMinHealthPercent()) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    hash = (37 * hash) + CONSECUTIVE_ERRORS_FIELD_NUMBER;
    hash = (53 * hash) + getConsecutiveErrors();
    if (hasConsecutiveGatewayErrors()) {
      hash = (37 * hash) + CONSECUTIVE_GATEWAY_ERRORS_FIELD_NUMBER;
      hash = (53 * hash) + getConsecutiveGatewayErrors().hashCode();
    }
    if (hasConsecutive5XxErrors()) {
      hash = (37 * hash) + CONSECUTIVE_5XX_ERRORS_FIELD_NUMBER;
      hash = (53 * hash) + getConsecutive5XxErrors().hashCode();
    }
    if (hasInterval()) {
      hash = (37 * hash) + INTERVAL_FIELD_NUMBER;
      hash = (53 * hash) + getInterval().hashCode();
    }
    if (hasBaseEjectionTime()) {
      hash = (37 * hash) + BASE_EJECTION_TIME_FIELD_NUMBER;
      hash = (53 * hash) + getBaseEjectionTime().hashCode();
    }
    hash = (37 * hash) + MAX_EJECTION_PERCENT_FIELD_NUMBER;
    hash = (53 * hash) + getMaxEjectionPercent();
    hash = (37 * hash) + MIN_HEALTH_PERCENT_FIELD_NUMBER;
    hash = (53 * hash) + getMinHealthPercent();
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.ourea.adapter.model.istio.OutlierDetection parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.ourea.adapter.model.istio.OutlierDetection prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * A Circuit breaker implementation that tracks the status of each
   * individual host in the upstream service.  Applicable to both HTTP and
   * TCP services.  For HTTP services, hosts that continually return 5xx
   * errors for API calls are ejected from the pool for a pre-defined period
   * of time. For TCP services, connection timeouts or connection
   * failures to a given host counts as an error when measuring the
   * consecutive errors metric. See Envoy's [outlier
   * detection](https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/upstream/outlier)
   * for more details.
   * The following rule sets a connection pool size of 100 HTTP1 connections
   * with no more than 10 req/connection to the "reviews" service. In addition,
   * it sets a limit of 1000 concurrent HTTP2 requests and configures upstream
   * hosts to be scanned every 5 mins so that any host that fails 7 consecutive
   * times with a 502, 503, or 504 error code will be ejected for 15 minutes.
   * {{&lt;tabset category-name="example"&gt;}}
   * {{&lt;tab name="v1alpha3" category-value="v1alpha3"&gt;}}
   * ```yaml
   * apiVersion: networking.istio.io/v1alpha3
   * kind: DestinationRule
   * metadata:
   *   name: reviews-cb-policy
   * spec:
   *   host: reviews.prod.svc.cluster.local
   *   trafficPolicy:
   *     connectionPool:
   *       tcp:
   *         maxConnections: 100
   *       http:
   *         http2MaxRequests: 1000
   *         maxRequestsPerConnection: 10
   *     outlierDetection:
   *       consecutiveErrors: 7
   *       interval: 5m
   *       baseEjectionTime: 15m
   * ```
   * {{&lt;/tab&gt;}}
   * {{&lt;tab name="v1beta1" category-value="v1beta1"&gt;}}
   * ```yaml
   * apiVersion: networking.istio.io/v1beta1
   * kind: DestinationRule
   * metadata:
   *   name: reviews-cb-policy
   * spec:
   *   host: reviews.prod.svc.cluster.local
   *   trafficPolicy:
   *     connectionPool:
   *       tcp:
   *         maxConnections: 100
   *       http:
   *         http2MaxRequests: 1000
   *         maxRequestsPerConnection: 10
   *     outlierDetection:
   *       consecutiveErrors: 7
   *       interval: 5m
   *       baseEjectionTime: 15m
   * ```
   * {{&lt;/tab&gt;}}
   * {{&lt;/tabset&gt;}}
   * </pre>
   *
   * Protobuf type {@code istio.networking.v1alpha3.OutlierDetection}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:istio.networking.v1alpha3.OutlierDetection)
      io.ourea.adapter.model.istio.OutlierDetectionOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.ourea.adapter.model.istio.DestinationRuleOuterClass.internal_static_istio_networking_v1alpha3_OutlierDetection_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.ourea.adapter.model.istio.DestinationRuleOuterClass.internal_static_istio_networking_v1alpha3_OutlierDetection_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.ourea.adapter.model.istio.OutlierDetection.class, io.ourea.adapter.model.istio.OutlierDetection.Builder.class);
    }

    // Construct using io.ourea.adapter.model.istio.OutlierDetection.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      consecutiveErrors_ = 0;

      if (consecutiveGatewayErrorsBuilder_ == null) {
        consecutiveGatewayErrors_ = null;
      } else {
        consecutiveGatewayErrors_ = null;
        consecutiveGatewayErrorsBuilder_ = null;
      }
      if (consecutive5XxErrorsBuilder_ == null) {
        consecutive5XxErrors_ = null;
      } else {
        consecutive5XxErrors_ = null;
        consecutive5XxErrorsBuilder_ = null;
      }
      if (intervalBuilder_ == null) {
        interval_ = null;
      } else {
        interval_ = null;
        intervalBuilder_ = null;
      }
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTime_ = null;
      } else {
        baseEjectionTime_ = null;
        baseEjectionTimeBuilder_ = null;
      }
      maxEjectionPercent_ = 0;

      minHealthPercent_ = 0;

      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.ourea.adapter.model.istio.DestinationRuleOuterClass.internal_static_istio_networking_v1alpha3_OutlierDetection_descriptor;
    }

    @java.lang.Override
    public io.ourea.adapter.model.istio.OutlierDetection getDefaultInstanceForType() {
      return io.ourea.adapter.model.istio.OutlierDetection.getDefaultInstance();
    }

    @java.lang.Override
    public io.ourea.adapter.model.istio.OutlierDetection build() {
      io.ourea.adapter.model.istio.OutlierDetection result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.ourea.adapter.model.istio.OutlierDetection buildPartial() {
      io.ourea.adapter.model.istio.OutlierDetection result = new io.ourea.adapter.model.istio.OutlierDetection(this);
      result.consecutiveErrors_ = consecutiveErrors_;
      if (consecutiveGatewayErrorsBuilder_ == null) {
        result.consecutiveGatewayErrors_ = consecutiveGatewayErrors_;
      } else {
        result.consecutiveGatewayErrors_ = consecutiveGatewayErrorsBuilder_.build();
      }
      if (consecutive5XxErrorsBuilder_ == null) {
        result.consecutive5XxErrors_ = consecutive5XxErrors_;
      } else {
        result.consecutive5XxErrors_ = consecutive5XxErrorsBuilder_.build();
      }
      if (intervalBuilder_ == null) {
        result.interval_ = interval_;
      } else {
        result.interval_ = intervalBuilder_.build();
      }
      if (baseEjectionTimeBuilder_ == null) {
        result.baseEjectionTime_ = baseEjectionTime_;
      } else {
        result.baseEjectionTime_ = baseEjectionTimeBuilder_.build();
      }
      result.maxEjectionPercent_ = maxEjectionPercent_;
      result.minHealthPercent_ = minHealthPercent_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.ourea.adapter.model.istio.OutlierDetection) {
        return mergeFrom((io.ourea.adapter.model.istio.OutlierDetection)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.ourea.adapter.model.istio.OutlierDetection other) {
      if (other == io.ourea.adapter.model.istio.OutlierDetection.getDefaultInstance()) return this;
      if (other.getConsecutiveErrors() != 0) {
        setConsecutiveErrors(other.getConsecutiveErrors());
      }
      if (other.hasConsecutiveGatewayErrors()) {
        mergeConsecutiveGatewayErrors(other.getConsecutiveGatewayErrors());
      }
      if (other.hasConsecutive5XxErrors()) {
        mergeConsecutive5XxErrors(other.getConsecutive5XxErrors());
      }
      if (other.hasInterval()) {
        mergeInterval(other.getInterval());
      }
      if (other.hasBaseEjectionTime()) {
        mergeBaseEjectionTime(other.getBaseEjectionTime());
      }
      if (other.getMaxEjectionPercent() != 0) {
        setMaxEjectionPercent(other.getMaxEjectionPercent());
      }
      if (other.getMinHealthPercent() != 0) {
        setMinHealthPercent(other.getMinHealthPercent());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.ourea.adapter.model.istio.OutlierDetection parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.ourea.adapter.model.istio.OutlierDetection) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }

    private int consecutiveErrors_ ;
    /**
     * <pre>
     * Number of errors before a host is ejected from the connection
     * pool. Defaults to 5. When the upstream host is accessed over HTTP, a
     * 502, 503, or 504 return code qualifies as an error. When the upstream host
     * is accessed over an opaque TCP connection, connect timeouts and
     * connection error/failure events qualify as an error.
     * $hide_from_docs
     * </pre>
     *
     * <code>int32 consecutive_errors = 1 [deprecated = true];</code>
     * @return The consecutiveErrors.
     */
    @java.lang.Override
    @java.lang.Deprecated public int getConsecutiveErrors() {
      return consecutiveErrors_;
    }
    /**
     * <pre>
     * Number of errors before a host is ejected from the connection
     * pool. Defaults to 5. When the upstream host is accessed over HTTP, a
     * 502, 503, or 504 return code qualifies as an error. When the upstream host
     * is accessed over an opaque TCP connection, connect timeouts and
     * connection error/failure events qualify as an error.
     * $hide_from_docs
     * </pre>
     *
     * <code>int32 consecutive_errors = 1 [deprecated = true];</code>
     * @param value The consecutiveErrors to set.
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder setConsecutiveErrors(int value) {
      
      consecutiveErrors_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Number of errors before a host is ejected from the connection
     * pool. Defaults to 5. When the upstream host is accessed over HTTP, a
     * 502, 503, or 504 return code qualifies as an error. When the upstream host
     * is accessed over an opaque TCP connection, connect timeouts and
     * connection error/failure events qualify as an error.
     * $hide_from_docs
     * </pre>
     *
     * <code>int32 consecutive_errors = 1 [deprecated = true];</code>
     * @return This builder for chaining.
     */
    @java.lang.Deprecated public Builder clearConsecutiveErrors() {
      
      consecutiveErrors_ = 0;
      onChanged();
      return this;
    }

    private com.google.protobuf.UInt32Value consecutiveGatewayErrors_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> consecutiveGatewayErrorsBuilder_;
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     * @return Whether the consecutiveGatewayErrors field is set.
     */
    public boolean hasConsecutiveGatewayErrors() {
      return consecutiveGatewayErrorsBuilder_ != null || consecutiveGatewayErrors_ != null;
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     * @return The consecutiveGatewayErrors.
     */
    public com.google.protobuf.UInt32Value getConsecutiveGatewayErrors() {
      if (consecutiveGatewayErrorsBuilder_ == null) {
        return consecutiveGatewayErrors_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : consecutiveGatewayErrors_;
      } else {
        return consecutiveGatewayErrorsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    public Builder setConsecutiveGatewayErrors(com.google.protobuf.UInt32Value value) {
      if (consecutiveGatewayErrorsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        consecutiveGatewayErrors_ = value;
        onChanged();
      } else {
        consecutiveGatewayErrorsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    public Builder setConsecutiveGatewayErrors(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (consecutiveGatewayErrorsBuilder_ == null) {
        consecutiveGatewayErrors_ = builderForValue.build();
        onChanged();
      } else {
        consecutiveGatewayErrorsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    public Builder mergeConsecutiveGatewayErrors(com.google.protobuf.UInt32Value value) {
      if (consecutiveGatewayErrorsBuilder_ == null) {
        if (consecutiveGatewayErrors_ != null) {
          consecutiveGatewayErrors_ =
            com.google.protobuf.UInt32Value.newBuilder(consecutiveGatewayErrors_).mergeFrom(value).buildPartial();
        } else {
          consecutiveGatewayErrors_ = value;
        }
        onChanged();
      } else {
        consecutiveGatewayErrorsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    public Builder clearConsecutiveGatewayErrors() {
      if (consecutiveGatewayErrorsBuilder_ == null) {
        consecutiveGatewayErrors_ = null;
        onChanged();
      } else {
        consecutiveGatewayErrors_ = null;
        consecutiveGatewayErrorsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getConsecutiveGatewayErrorsBuilder() {
      
      onChanged();
      return getConsecutiveGatewayErrorsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getConsecutiveGatewayErrorsOrBuilder() {
      if (consecutiveGatewayErrorsBuilder_ != null) {
        return consecutiveGatewayErrorsBuilder_.getMessageOrBuilder();
      } else {
        return consecutiveGatewayErrors_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : consecutiveGatewayErrors_;
      }
    }
    /**
     * <pre>
     * Number of gateway errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over HTTP, a 502, 503, or 504 return
     * code qualifies as a gateway error. When the upstream host is accessed over
     * an opaque TCP connection, connect timeouts and connection error/failure
     * events qualify as a gateway error.
     * This feature is disabled by default or when set to the value 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_gateway_errors = 6;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getConsecutiveGatewayErrorsFieldBuilder() {
      if (consecutiveGatewayErrorsBuilder_ == null) {
        consecutiveGatewayErrorsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getConsecutiveGatewayErrors(),
                getParentForChildren(),
                isClean());
        consecutiveGatewayErrors_ = null;
      }
      return consecutiveGatewayErrorsBuilder_;
    }

    private com.google.protobuf.UInt32Value consecutive5XxErrors_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> consecutive5XxErrorsBuilder_;
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     * @return Whether the consecutive5xxErrors field is set.
     */
    public boolean hasConsecutive5XxErrors() {
      return consecutive5XxErrorsBuilder_ != null || consecutive5XxErrors_ != null;
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     * @return The consecutive5xxErrors.
     */
    public com.google.protobuf.UInt32Value getConsecutive5XxErrors() {
      if (consecutive5XxErrorsBuilder_ == null) {
        return consecutive5XxErrors_ == null ? com.google.protobuf.UInt32Value.getDefaultInstance() : consecutive5XxErrors_;
      } else {
        return consecutive5XxErrorsBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    public Builder setConsecutive5XxErrors(com.google.protobuf.UInt32Value value) {
      if (consecutive5XxErrorsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        consecutive5XxErrors_ = value;
        onChanged();
      } else {
        consecutive5XxErrorsBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    public Builder setConsecutive5XxErrors(
        com.google.protobuf.UInt32Value.Builder builderForValue) {
      if (consecutive5XxErrorsBuilder_ == null) {
        consecutive5XxErrors_ = builderForValue.build();
        onChanged();
      } else {
        consecutive5XxErrorsBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    public Builder mergeConsecutive5XxErrors(com.google.protobuf.UInt32Value value) {
      if (consecutive5XxErrorsBuilder_ == null) {
        if (consecutive5XxErrors_ != null) {
          consecutive5XxErrors_ =
            com.google.protobuf.UInt32Value.newBuilder(consecutive5XxErrors_).mergeFrom(value).buildPartial();
        } else {
          consecutive5XxErrors_ = value;
        }
        onChanged();
      } else {
        consecutive5XxErrorsBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    public Builder clearConsecutive5XxErrors() {
      if (consecutive5XxErrorsBuilder_ == null) {
        consecutive5XxErrors_ = null;
        onChanged();
      } else {
        consecutive5XxErrors_ = null;
        consecutive5XxErrorsBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    public com.google.protobuf.UInt32Value.Builder getConsecutive5XxErrorsBuilder() {
      
      onChanged();
      return getConsecutive5XxErrorsFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    public com.google.protobuf.UInt32ValueOrBuilder getConsecutive5XxErrorsOrBuilder() {
      if (consecutive5XxErrorsBuilder_ != null) {
        return consecutive5XxErrorsBuilder_.getMessageOrBuilder();
      } else {
        return consecutive5XxErrors_ == null ?
            com.google.protobuf.UInt32Value.getDefaultInstance() : consecutive5XxErrors_;
      }
    }
    /**
     * <pre>
     * Number of 5xx errors before a host is ejected from the connection pool.
     * When the upstream host is accessed over an opaque TCP connection, connect
     * timeouts, connection error/failure and request failure events qualify as a
     * 5xx error.
     * This feature defaults to 5 but can be disabled by setting the value to 0.
     * Note that consecutive_gateway_errors and consecutive_5xx_errors can be
     * used separately or together. Because the errors counted by
     * consecutive_gateway_errors are also included in consecutive_5xx_errors,
     * if the value of consecutive_gateway_errors is greater than or equal to
     * the value of consecutive_5xx_errors, consecutive_gateway_errors will have
     * no effect.
     * </pre>
     *
     * <code>.google.protobuf.UInt32Value consecutive_5xx_errors = 7;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder> 
        getConsecutive5XxErrorsFieldBuilder() {
      if (consecutive5XxErrorsBuilder_ == null) {
        consecutive5XxErrorsBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.UInt32Value, com.google.protobuf.UInt32Value.Builder, com.google.protobuf.UInt32ValueOrBuilder>(
                getConsecutive5XxErrors(),
                getParentForChildren(),
                isClean());
        consecutive5XxErrors_ = null;
      }
      return consecutive5XxErrorsBuilder_;
    }

    private com.google.protobuf.Duration interval_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> intervalBuilder_;
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     * @return Whether the interval field is set.
     */
    public boolean hasInterval() {
      return intervalBuilder_ != null || interval_ != null;
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     * @return The interval.
     */
    public com.google.protobuf.Duration getInterval() {
      if (intervalBuilder_ == null) {
        return interval_ == null ? com.google.protobuf.Duration.getDefaultInstance() : interval_;
      } else {
        return intervalBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    public Builder setInterval(com.google.protobuf.Duration value) {
      if (intervalBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        interval_ = value;
        onChanged();
      } else {
        intervalBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    public Builder setInterval(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (intervalBuilder_ == null) {
        interval_ = builderForValue.build();
        onChanged();
      } else {
        intervalBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    public Builder mergeInterval(com.google.protobuf.Duration value) {
      if (intervalBuilder_ == null) {
        if (interval_ != null) {
          interval_ =
            com.google.protobuf.Duration.newBuilder(interval_).mergeFrom(value).buildPartial();
        } else {
          interval_ = value;
        }
        onChanged();
      } else {
        intervalBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    public Builder clearInterval() {
      if (intervalBuilder_ == null) {
        interval_ = null;
        onChanged();
      } else {
        interval_ = null;
        intervalBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    public com.google.protobuf.Duration.Builder getIntervalBuilder() {
      
      onChanged();
      return getIntervalFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    public com.google.protobuf.DurationOrBuilder getIntervalOrBuilder() {
      if (intervalBuilder_ != null) {
        return intervalBuilder_.getMessageOrBuilder();
      } else {
        return interval_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : interval_;
      }
    }
    /**
     * <pre>
     * Time interval between ejection sweep analysis. format:
     * 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 10s.
     * </pre>
     *
     * <code>.google.protobuf.Duration interval = 2;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getIntervalFieldBuilder() {
      if (intervalBuilder_ == null) {
        intervalBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getInterval(),
                getParentForChildren(),
                isClean());
        interval_ = null;
      }
      return intervalBuilder_;
    }

    private com.google.protobuf.Duration baseEjectionTime_;
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> baseEjectionTimeBuilder_;
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     * @return Whether the baseEjectionTime field is set.
     */
    public boolean hasBaseEjectionTime() {
      return baseEjectionTimeBuilder_ != null || baseEjectionTime_ != null;
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     * @return The baseEjectionTime.
     */
    public com.google.protobuf.Duration getBaseEjectionTime() {
      if (baseEjectionTimeBuilder_ == null) {
        return baseEjectionTime_ == null ? com.google.protobuf.Duration.getDefaultInstance() : baseEjectionTime_;
      } else {
        return baseEjectionTimeBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    public Builder setBaseEjectionTime(com.google.protobuf.Duration value) {
      if (baseEjectionTimeBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        baseEjectionTime_ = value;
        onChanged();
      } else {
        baseEjectionTimeBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    public Builder setBaseEjectionTime(
        com.google.protobuf.Duration.Builder builderForValue) {
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTime_ = builderForValue.build();
        onChanged();
      } else {
        baseEjectionTimeBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    public Builder mergeBaseEjectionTime(com.google.protobuf.Duration value) {
      if (baseEjectionTimeBuilder_ == null) {
        if (baseEjectionTime_ != null) {
          baseEjectionTime_ =
            com.google.protobuf.Duration.newBuilder(baseEjectionTime_).mergeFrom(value).buildPartial();
        } else {
          baseEjectionTime_ = value;
        }
        onChanged();
      } else {
        baseEjectionTimeBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    public Builder clearBaseEjectionTime() {
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTime_ = null;
        onChanged();
      } else {
        baseEjectionTime_ = null;
        baseEjectionTimeBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    public com.google.protobuf.Duration.Builder getBaseEjectionTimeBuilder() {
      
      onChanged();
      return getBaseEjectionTimeFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    public com.google.protobuf.DurationOrBuilder getBaseEjectionTimeOrBuilder() {
      if (baseEjectionTimeBuilder_ != null) {
        return baseEjectionTimeBuilder_.getMessageOrBuilder();
      } else {
        return baseEjectionTime_ == null ?
            com.google.protobuf.Duration.getDefaultInstance() : baseEjectionTime_;
      }
    }
    /**
     * <pre>
     * Minimum ejection duration. A host will remain ejected for a period
     * equal to the product of minimum ejection duration and the number of
     * times the host has been ejected. This technique allows the system to
     * automatically increase the ejection period for unhealthy upstream
     * servers. format: 1h/1m/1s/1ms. MUST BE &gt;=1ms. Default is 30s.
     * </pre>
     *
     * <code>.google.protobuf.Duration base_ejection_time = 3;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder> 
        getBaseEjectionTimeFieldBuilder() {
      if (baseEjectionTimeBuilder_ == null) {
        baseEjectionTimeBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            com.google.protobuf.Duration, com.google.protobuf.Duration.Builder, com.google.protobuf.DurationOrBuilder>(
                getBaseEjectionTime(),
                getParentForChildren(),
                isClean());
        baseEjectionTime_ = null;
      }
      return baseEjectionTimeBuilder_;
    }

    private int maxEjectionPercent_ ;
    /**
     * <pre>
     * Maximum % of hosts in the load balancing pool for the upstream
     * service that can be ejected. Defaults to 10%.
     * </pre>
     *
     * <code>int32 max_ejection_percent = 4;</code>
     * @return The maxEjectionPercent.
     */
    @java.lang.Override
    public int getMaxEjectionPercent() {
      return maxEjectionPercent_;
    }
    /**
     * <pre>
     * Maximum % of hosts in the load balancing pool for the upstream
     * service that can be ejected. Defaults to 10%.
     * </pre>
     *
     * <code>int32 max_ejection_percent = 4;</code>
     * @param value The maxEjectionPercent to set.
     * @return This builder for chaining.
     */
    public Builder setMaxEjectionPercent(int value) {
      
      maxEjectionPercent_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Maximum % of hosts in the load balancing pool for the upstream
     * service that can be ejected. Defaults to 10%.
     * </pre>
     *
     * <code>int32 max_ejection_percent = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearMaxEjectionPercent() {
      
      maxEjectionPercent_ = 0;
      onChanged();
      return this;
    }

    private int minHealthPercent_ ;
    /**
     * <pre>
     * Outlier detection will be enabled as long as the associated load balancing
     * pool has at least min_health_percent hosts in healthy mode. When the
     * percentage of healthy hosts in the load balancing pool drops below this
     * threshold, outlier detection will be disabled and the proxy will load balance
     * across all hosts in the pool (healthy and unhealthy). The threshold can be
     * disabled by setting it to 0%. The default is 0% as it's not typically
     * applicable in k8s environments with few pods per service.
     * </pre>
     *
     * <code>int32 min_health_percent = 5;</code>
     * @return The minHealthPercent.
     */
    @java.lang.Override
    public int getMinHealthPercent() {
      return minHealthPercent_;
    }
    /**
     * <pre>
     * Outlier detection will be enabled as long as the associated load balancing
     * pool has at least min_health_percent hosts in healthy mode. When the
     * percentage of healthy hosts in the load balancing pool drops below this
     * threshold, outlier detection will be disabled and the proxy will load balance
     * across all hosts in the pool (healthy and unhealthy). The threshold can be
     * disabled by setting it to 0%. The default is 0% as it's not typically
     * applicable in k8s environments with few pods per service.
     * </pre>
     *
     * <code>int32 min_health_percent = 5;</code>
     * @param value The minHealthPercent to set.
     * @return This builder for chaining.
     */
    public Builder setMinHealthPercent(int value) {
      
      minHealthPercent_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Outlier detection will be enabled as long as the associated load balancing
     * pool has at least min_health_percent hosts in healthy mode. When the
     * percentage of healthy hosts in the load balancing pool drops below this
     * threshold, outlier detection will be disabled and the proxy will load balance
     * across all hosts in the pool (healthy and unhealthy). The threshold can be
     * disabled by setting it to 0%. The default is 0% as it's not typically
     * applicable in k8s environments with few pods per service.
     * </pre>
     *
     * <code>int32 min_health_percent = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearMinHealthPercent() {
      
      minHealthPercent_ = 0;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:istio.networking.v1alpha3.OutlierDetection)
  }

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.OutlierDetection)
  private static final io.ourea.adapter.model.istio.OutlierDetection DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.ourea.adapter.model.istio.OutlierDetection();
  }

  public static io.ourea.adapter.model.istio.OutlierDetection getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<OutlierDetection>
      PARSER = new com.google.protobuf.AbstractParser<OutlierDetection>() {
    @java.lang.Override
    public OutlierDetection parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new OutlierDetection(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<OutlierDetection> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<OutlierDetection> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.ourea.adapter.model.istio.OutlierDetection getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

