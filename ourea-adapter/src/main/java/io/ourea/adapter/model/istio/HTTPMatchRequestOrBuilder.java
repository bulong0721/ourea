// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: virtual_service.proto

package io.ourea.adapter.model.istio;

public interface HTTPMatchRequestOrBuilder extends
    // @@protoc_insertion_point(interface_extends:istio.networking.v1alpha3.HTTPMatchRequest)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The name assigned to a match. The match's name will be
   * concatenated with the parent route's name and will be logged in
   * the access logs for requests matching this route.
   * </pre>
   *
   * <code>string name = 11;</code>
   * @return The name.
   */
  java.lang.String getName();
  /**
   * <pre>
   * The name assigned to a match. The match's name will be
   * concatenated with the parent route's name and will be logged in
   * the access logs for requests matching this route.
   * </pre>
   *
   * <code>string name = 11;</code>
   * @return The bytes for name.
   */
  com.google.protobuf.ByteString
      getNameBytes();

  /**
   * <pre>
   * URI to match
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * **Note:** Case-insensitive matching could be enabled via the
   * `ignore_uri_case` flag.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch uri = 1;</code>
   * @return Whether the uri field is set.
   */
  boolean hasUri();
  /**
   * <pre>
   * URI to match
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * **Note:** Case-insensitive matching could be enabled via the
   * `ignore_uri_case` flag.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch uri = 1;</code>
   * @return The uri.
   */
  io.ourea.adapter.model.istio.StringMatch getUri();
  /**
   * <pre>
   * URI to match
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * **Note:** Case-insensitive matching could be enabled via the
   * `ignore_uri_case` flag.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch uri = 1;</code>
   */
  io.ourea.adapter.model.istio.StringMatchOrBuilder getUriOrBuilder();

  /**
   * <pre>
   * URI Scheme
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch scheme = 2;</code>
   * @return Whether the scheme field is set.
   */
  boolean hasScheme();
  /**
   * <pre>
   * URI Scheme
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch scheme = 2;</code>
   * @return The scheme.
   */
  io.ourea.adapter.model.istio.StringMatch getScheme();
  /**
   * <pre>
   * URI Scheme
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch scheme = 2;</code>
   */
  io.ourea.adapter.model.istio.StringMatchOrBuilder getSchemeOrBuilder();

  /**
   * <pre>
   * HTTP Method
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch method = 3;</code>
   * @return Whether the method field is set.
   */
  boolean hasMethod();
  /**
   * <pre>
   * HTTP Method
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch method = 3;</code>
   * @return The method.
   */
  io.ourea.adapter.model.istio.StringMatch getMethod();
  /**
   * <pre>
   * HTTP Method
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch method = 3;</code>
   */
  io.ourea.adapter.model.istio.StringMatchOrBuilder getMethodOrBuilder();

  /**
   * <pre>
   * HTTP Authority
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch authority = 4;</code>
   * @return Whether the authority field is set.
   */
  boolean hasAuthority();
  /**
   * <pre>
   * HTTP Authority
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch authority = 4;</code>
   * @return The authority.
   */
  io.ourea.adapter.model.istio.StringMatch getAuthority();
  /**
   * <pre>
   * HTTP Authority
   * values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.StringMatch authority = 4;</code>
   */
  io.ourea.adapter.model.istio.StringMatchOrBuilder getAuthorityOrBuilder();

  /**
   * <pre>
   * The header keys must be lowercase and use hyphen as the separator,
   * e.g. _x-request-id_.
   * Header values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * If the value is empty and only the name of header is specfied, presence of the header is checked.
   * **Note:** The keys `uri`, `scheme`, `method`, and `authority` will be ignored.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; headers = 5;</code>
   */
  int getHeadersCount();
  /**
   * <pre>
   * The header keys must be lowercase and use hyphen as the separator,
   * e.g. _x-request-id_.
   * Header values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * If the value is empty and only the name of header is specfied, presence of the header is checked.
   * **Note:** The keys `uri`, `scheme`, `method`, and `authority` will be ignored.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; headers = 5;</code>
   */
  boolean containsHeaders(
      java.lang.String key);
  /**
   * Use {@link #getHeadersMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, io.ourea.adapter.model.istio.StringMatch>
  getHeaders();
  /**
   * <pre>
   * The header keys must be lowercase and use hyphen as the separator,
   * e.g. _x-request-id_.
   * Header values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * If the value is empty and only the name of header is specfied, presence of the header is checked.
   * **Note:** The keys `uri`, `scheme`, `method`, and `authority` will be ignored.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; headers = 5;</code>
   */
  java.util.Map<java.lang.String, io.ourea.adapter.model.istio.StringMatch>
  getHeadersMap();
  /**
   * <pre>
   * The header keys must be lowercase and use hyphen as the separator,
   * e.g. _x-request-id_.
   * Header values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * If the value is empty and only the name of header is specfied, presence of the header is checked.
   * **Note:** The keys `uri`, `scheme`, `method`, and `authority` will be ignored.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; headers = 5;</code>
   */

  io.ourea.adapter.model.istio.StringMatch getHeadersOrDefault(
      java.lang.String key,
      io.ourea.adapter.model.istio.StringMatch defaultValue);
  /**
   * <pre>
   * The header keys must be lowercase and use hyphen as the separator,
   * e.g. _x-request-id_.
   * Header values are case-sensitive and formatted as follows:
   * - `exact: "value"` for exact string match
   * - `prefix: "value"` for prefix-based match
   * - `regex: "value"` for ECMAscript style regex-based match
   * If the value is empty and only the name of header is specfied, presence of the header is checked.
   * **Note:** The keys `uri`, `scheme`, `method`, and `authority` will be ignored.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; headers = 5;</code>
   */

  io.ourea.adapter.model.istio.StringMatch getHeadersOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * Specifies the ports on the host that is being addressed. Many services
   * only expose a single port or label ports with the protocols they support,
   * in these cases it is not required to explicitly select the port.
   * </pre>
   *
   * <code>uint32 port = 6;</code>
   * @return The port.
   */
  int getPort();

  /**
   * <pre>
   * One or more labels that constrain the applicability of a rule to
   * workloads with the given labels. If the VirtualService has a list of
   * gateways specified in the top-level `gateways` field, it must include the reserved gateway
   * `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>map&lt;string, string&gt; source_labels = 7;</code>
   */
  int getSourceLabelsCount();
  /**
   * <pre>
   * One or more labels that constrain the applicability of a rule to
   * workloads with the given labels. If the VirtualService has a list of
   * gateways specified in the top-level `gateways` field, it must include the reserved gateway
   * `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>map&lt;string, string&gt; source_labels = 7;</code>
   */
  boolean containsSourceLabels(
      java.lang.String key);
  /**
   * Use {@link #getSourceLabelsMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, java.lang.String>
  getSourceLabels();
  /**
   * <pre>
   * One or more labels that constrain the applicability of a rule to
   * workloads with the given labels. If the VirtualService has a list of
   * gateways specified in the top-level `gateways` field, it must include the reserved gateway
   * `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>map&lt;string, string&gt; source_labels = 7;</code>
   */
  java.util.Map<java.lang.String, java.lang.String>
  getSourceLabelsMap();
  /**
   * <pre>
   * One or more labels that constrain the applicability of a rule to
   * workloads with the given labels. If the VirtualService has a list of
   * gateways specified in the top-level `gateways` field, it must include the reserved gateway
   * `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>map&lt;string, string&gt; source_labels = 7;</code>
   */

  java.lang.String getSourceLabelsOrDefault(
      java.lang.String key,
      java.lang.String defaultValue);
  /**
   * <pre>
   * One or more labels that constrain the applicability of a rule to
   * workloads with the given labels. If the VirtualService has a list of
   * gateways specified in the top-level `gateways` field, it must include the reserved gateway
   * `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>map&lt;string, string&gt; source_labels = 7;</code>
   */

  java.lang.String getSourceLabelsOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * Names of gateways where the rule should be applied. Gateway names
   * in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway
   * match is independent of sourceLabels.
   * </pre>
   *
   * <code>repeated string gateways = 8;</code>
   * @return A list containing the gateways.
   */
  java.util.List<java.lang.String>
      getGatewaysList();
  /**
   * <pre>
   * Names of gateways where the rule should be applied. Gateway names
   * in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway
   * match is independent of sourceLabels.
   * </pre>
   *
   * <code>repeated string gateways = 8;</code>
   * @return The count of gateways.
   */
  int getGatewaysCount();
  /**
   * <pre>
   * Names of gateways where the rule should be applied. Gateway names
   * in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway
   * match is independent of sourceLabels.
   * </pre>
   *
   * <code>repeated string gateways = 8;</code>
   * @param index The index of the element to return.
   * @return The gateways at the given index.
   */
  java.lang.String getGateways(int index);
  /**
   * <pre>
   * Names of gateways where the rule should be applied. Gateway names
   * in the top-level `gateways` field of the VirtualService (if any) are overridden. The gateway
   * match is independent of sourceLabels.
   * </pre>
   *
   * <code>repeated string gateways = 8;</code>
   * @param index The index of the value to return.
   * @return The bytes of the gateways at the given index.
   */
  com.google.protobuf.ByteString
      getGatewaysBytes(int index);

  /**
   * <pre>
   * Query parameters for matching.
   * Ex:
   * - For a query parameter like "?key=true", the map key would be "key" and
   *   the string match could be defined as `exact: "true"`.
   * - For a query parameter like "?key", the map key would be "key" and the
   *   string match could be defined as `exact: ""`.
   * - For a query parameter like "?key=123", the map key would be "key" and the
   *   string match could be defined as `regex: "&#92;d+$"`. Note that this
   *   configuration will only match values like "123" but not "a123" or "123a".
   * **Note:** `prefix` matching is currently not supported.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; query_params = 9;</code>
   */
  int getQueryParamsCount();
  /**
   * <pre>
   * Query parameters for matching.
   * Ex:
   * - For a query parameter like "?key=true", the map key would be "key" and
   *   the string match could be defined as `exact: "true"`.
   * - For a query parameter like "?key", the map key would be "key" and the
   *   string match could be defined as `exact: ""`.
   * - For a query parameter like "?key=123", the map key would be "key" and the
   *   string match could be defined as `regex: "&#92;d+$"`. Note that this
   *   configuration will only match values like "123" but not "a123" or "123a".
   * **Note:** `prefix` matching is currently not supported.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; query_params = 9;</code>
   */
  boolean containsQueryParams(
      java.lang.String key);
  /**
   * Use {@link #getQueryParamsMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, io.ourea.adapter.model.istio.StringMatch>
  getQueryParams();
  /**
   * <pre>
   * Query parameters for matching.
   * Ex:
   * - For a query parameter like "?key=true", the map key would be "key" and
   *   the string match could be defined as `exact: "true"`.
   * - For a query parameter like "?key", the map key would be "key" and the
   *   string match could be defined as `exact: ""`.
   * - For a query parameter like "?key=123", the map key would be "key" and the
   *   string match could be defined as `regex: "&#92;d+$"`. Note that this
   *   configuration will only match values like "123" but not "a123" or "123a".
   * **Note:** `prefix` matching is currently not supported.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; query_params = 9;</code>
   */
  java.util.Map<java.lang.String, io.ourea.adapter.model.istio.StringMatch>
  getQueryParamsMap();
  /**
   * <pre>
   * Query parameters for matching.
   * Ex:
   * - For a query parameter like "?key=true", the map key would be "key" and
   *   the string match could be defined as `exact: "true"`.
   * - For a query parameter like "?key", the map key would be "key" and the
   *   string match could be defined as `exact: ""`.
   * - For a query parameter like "?key=123", the map key would be "key" and the
   *   string match could be defined as `regex: "&#92;d+$"`. Note that this
   *   configuration will only match values like "123" but not "a123" or "123a".
   * **Note:** `prefix` matching is currently not supported.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; query_params = 9;</code>
   */

  io.ourea.adapter.model.istio.StringMatch getQueryParamsOrDefault(
      java.lang.String key,
      io.ourea.adapter.model.istio.StringMatch defaultValue);
  /**
   * <pre>
   * Query parameters for matching.
   * Ex:
   * - For a query parameter like "?key=true", the map key would be "key" and
   *   the string match could be defined as `exact: "true"`.
   * - For a query parameter like "?key", the map key would be "key" and the
   *   string match could be defined as `exact: ""`.
   * - For a query parameter like "?key=123", the map key would be "key" and the
   *   string match could be defined as `regex: "&#92;d+$"`. Note that this
   *   configuration will only match values like "123" but not "a123" or "123a".
   * **Note:** `prefix` matching is currently not supported.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; query_params = 9;</code>
   */

  io.ourea.adapter.model.istio.StringMatch getQueryParamsOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * Flag to specify whether the URI matching should be case-insensitive.
   * **Note:** The case will be ignored only in the case of `exact` and `prefix`
   * URI matches.
   * </pre>
   *
   * <code>bool ignore_uri_case = 10;</code>
   * @return The ignoreUriCase.
   */
  boolean getIgnoreUriCase();

  /**
   * <pre>
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   * If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; without_headers = 12;</code>
   */
  int getWithoutHeadersCount();
  /**
   * <pre>
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   * If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; without_headers = 12;</code>
   */
  boolean containsWithoutHeaders(
      java.lang.String key);
  /**
   * Use {@link #getWithoutHeadersMap()} instead.
   */
  @java.lang.Deprecated
  java.util.Map<java.lang.String, io.ourea.adapter.model.istio.StringMatch>
  getWithoutHeaders();
  /**
   * <pre>
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   * If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; without_headers = 12;</code>
   */
  java.util.Map<java.lang.String, io.ourea.adapter.model.istio.StringMatch>
  getWithoutHeadersMap();
  /**
   * <pre>
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   * If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; without_headers = 12;</code>
   */

  io.ourea.adapter.model.istio.StringMatch getWithoutHeadersOrDefault(
      java.lang.String key,
      io.ourea.adapter.model.istio.StringMatch defaultValue);
  /**
   * <pre>
   * withoutHeader has the same syntax with the header, but has opposite meaning.
   * If a header is matched with a matching rule among withoutHeader, the traffic becomes not matched one.
   * </pre>
   *
   * <code>map&lt;string, .istio.networking.v1alpha3.StringMatch&gt; without_headers = 12;</code>
   */

  io.ourea.adapter.model.istio.StringMatch getWithoutHeadersOrThrow(
      java.lang.String key);

  /**
   * <pre>
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   * If the VirtualService has a list of gateways specified in the top-level `gateways` field,
   * it must include the reserved gateway `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>string source_namespace = 13;</code>
   * @return The sourceNamespace.
   */
  java.lang.String getSourceNamespace();
  /**
   * <pre>
   * Source namespace constraining the applicability of a rule to workloads in that namespace.
   * If the VirtualService has a list of gateways specified in the top-level `gateways` field,
   * it must include the reserved gateway `mesh` for this field to be applicable.
   * </pre>
   *
   * <code>string source_namespace = 13;</code>
   * @return The bytes for sourceNamespace.
   */
  com.google.protobuf.ByteString
      getSourceNamespaceBytes();
}
