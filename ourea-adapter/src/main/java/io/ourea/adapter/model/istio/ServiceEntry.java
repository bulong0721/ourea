// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service_entry.proto

package io.ourea.adapter.model.istio;

/**
 * <pre>
 * ServiceEntry enables adding additional entries into Istio's internal
 * service registry.
 * &lt;!-- crd generation tags
 * +cue-gen:ServiceEntry:groupName:networking.istio.io
 * +cue-gen:ServiceEntry:version:v1alpha3
 * +cue-gen:ServiceEntry:storageVersion
 * +cue-gen:ServiceEntry:annotations:helm.sh/resource-policy=keep
 * +cue-gen:ServiceEntry:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
 * +cue-gen:ServiceEntry:subresource:status
 * +cue-gen:ServiceEntry:scope:Namespaced
 * +cue-gen:ServiceEntry:resource:categories=istio-io,networking-istio-io,shortNames=se,plural=serviceentries
 * +cue-gen:ServiceEntry:printerColumn:name=Hosts,type=string,JSONPath=.spec.hosts,description="The hosts associated with the ServiceEntry"
 * +cue-gen:ServiceEntry:printerColumn:name=Location,type=string,JSONPath=.spec.location,description="Whether the service is external to the
 * mesh or part of the mesh (MESH_EXTERNAL or MESH_INTERNAL)"
 * +cue-gen:ServiceEntry:printerColumn:name=Resolution,type=string,JSONPath=.spec.resolution,description="Service discovery mode for the hosts
 * (NONE, STATIC, or DNS)"
 * +cue-gen:ServiceEntry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
 * representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
 * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
 * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
 * --&gt;
 * &lt;!-- go code generation tags
 * +kubetype-gen
 * +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
 * +genclient
 * +k8s:deepcopy-gen=true
 * --&gt;
 * </pre>
 *
 * Protobuf type {@code istio.networking.v1alpha3.ServiceEntry}
 */
public final class ServiceEntry extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:istio.networking.v1alpha3.ServiceEntry)
    ServiceEntryOrBuilder {
private static final long serialVersionUID = 0L;
  // Use ServiceEntry.newBuilder() to construct.
  private ServiceEntry(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private ServiceEntry() {
    hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    ports_ = java.util.Collections.emptyList();
    location_ = 0;
    resolution_ = 0;
    endpoints_ = java.util.Collections.emptyList();
    exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new ServiceEntry();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private ServiceEntry(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 10: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000001) != 0)) {
              hosts_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000001;
            }
            hosts_.add(s);
            break;
          }
          case 18: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000002) != 0)) {
              addresses_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000002;
            }
            addresses_.add(s);
            break;
          }
          case 26: {
            if (!((mutable_bitField0_ & 0x00000004) != 0)) {
              ports_ = new java.util.ArrayList<io.ourea.adapter.model.Port>();
              mutable_bitField0_ |= 0x00000004;
            }
            ports_.add(
                input.readMessage(io.ourea.adapter.model.Port.parser(), extensionRegistry));
            break;
          }
          case 32: {
            int rawValue = input.readEnum();

            location_ = rawValue;
            break;
          }
          case 40: {
            int rawValue = input.readEnum();

            resolution_ = rawValue;
            break;
          }
          case 50: {
            if (!((mutable_bitField0_ & 0x00000008) != 0)) {
              endpoints_ = new java.util.ArrayList<io.ourea.adapter.model.istio.WorkloadEntry>();
              mutable_bitField0_ |= 0x00000008;
            }
            endpoints_.add(
                input.readMessage(io.ourea.adapter.model.istio.WorkloadEntry.parser(), extensionRegistry));
            break;
          }
          case 58: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000010) != 0)) {
              exportTo_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000010;
            }
            exportTo_.add(s);
            break;
          }
          case 66: {
            java.lang.String s = input.readStringRequireUtf8();
            if (!((mutable_bitField0_ & 0x00000020) != 0)) {
              subjectAltNames_ = new com.google.protobuf.LazyStringArrayList();
              mutable_bitField0_ |= 0x00000020;
            }
            subjectAltNames_.add(s);
            break;
          }
          case 74: {
            io.ourea.adapter.model.istio.WorkloadSelector.Builder subBuilder = null;
            if (workloadSelector_ != null) {
              subBuilder = workloadSelector_.toBuilder();
            }
            workloadSelector_ = input.readMessage(io.ourea.adapter.model.istio.WorkloadSelector.parser(), extensionRegistry);
            if (subBuilder != null) {
              subBuilder.mergeFrom(workloadSelector_);
              workloadSelector_ = subBuilder.buildPartial();
            }

            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      if (((mutable_bitField0_ & 0x00000001) != 0)) {
        hosts_ = hosts_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000002) != 0)) {
        addresses_ = addresses_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000004) != 0)) {
        ports_ = java.util.Collections.unmodifiableList(ports_);
      }
      if (((mutable_bitField0_ & 0x00000008) != 0)) {
        endpoints_ = java.util.Collections.unmodifiableList(endpoints_);
      }
      if (((mutable_bitField0_ & 0x00000010) != 0)) {
        exportTo_ = exportTo_.getUnmodifiableView();
      }
      if (((mutable_bitField0_ & 0x00000020) != 0)) {
        subjectAltNames_ = subjectAltNames_.getUnmodifiableView();
      }
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return io.ourea.adapter.model.istio.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return io.ourea.adapter.model.istio.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            io.ourea.adapter.model.istio.ServiceEntry.class, io.ourea.adapter.model.istio.ServiceEntry.Builder.class);
  }

  /**
   * <pre>
   * Location specifies whether the service is part of Istio mesh or
   * outside the mesh.  Location determines the behavior of several
   * features, such as service-to-service mTLS authentication, policy
   * enforcement, etc. When communicating with services outside the mesh,
   * Istio's mTLS authentication is disabled, and policy enforcement is
   * performed on the client-side as opposed to server-side.
   * </pre>
   *
   * Protobuf enum {@code istio.networking.v1alpha3.ServiceEntry.Location}
   */
  public enum Location
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Signifies that the service is external to the mesh. Typically used
     * to indicate external services consumed through APIs.
     * </pre>
     *
     * <code>MESH_EXTERNAL = 0;</code>
     */
    MESH_EXTERNAL(0),
    /**
     * <pre>
     * Signifies that the service is part of the mesh. Typically used to
     * indicate services added explicitly as part of expanding the service
     * mesh to include unmanaged infrastructure (e.g., VMs added to a
     * Kubernetes based service mesh).
     * </pre>
     *
     * <code>MESH_INTERNAL = 1;</code>
     */
    MESH_INTERNAL(1),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Signifies that the service is external to the mesh. Typically used
     * to indicate external services consumed through APIs.
     * </pre>
     *
     * <code>MESH_EXTERNAL = 0;</code>
     */
    public static final int MESH_EXTERNAL_VALUE = 0;
    /**
     * <pre>
     * Signifies that the service is part of the mesh. Typically used to
     * indicate services added explicitly as part of expanding the service
     * mesh to include unmanaged infrastructure (e.g., VMs added to a
     * Kubernetes based service mesh).
     * </pre>
     *
     * <code>MESH_INTERNAL = 1;</code>
     */
    public static final int MESH_INTERNAL_VALUE = 1;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Location valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Location forNumber(int value) {
      switch (value) {
        case 0: return MESH_EXTERNAL;
        case 1: return MESH_INTERNAL;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Location>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Location> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Location>() {
            public Location findValueByNumber(int number) {
              return Location.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.ourea.adapter.model.istio.ServiceEntry.getDescriptor().getEnumTypes().get(0);
    }

    private static final Location[] VALUES = values();

    public static Location valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Location(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:istio.networking.v1alpha3.ServiceEntry.Location)
  }

  /**
   * <pre>
   * Resolution determines how the proxy will resolve the IP addresses of
   * the network endpoints associated with the service, so that it can
   * route to one of them. The resolution mode specified here has no impact
   * on how the application resolves the IP address associated with the
   * service. The application may still have to use DNS to resolve the
   * service to an IP so that the outbound traffic can be captured by the
   * Proxy. Alternatively, for HTTP services, the application could
   * directly communicate with the proxy (e.g., by setting HTTP_PROXY) to
   * talk to these services.
   * </pre>
   *
   * Protobuf enum {@code istio.networking.v1alpha3.ServiceEntry.Resolution}
   */
  public enum Resolution
      implements com.google.protobuf.ProtocolMessageEnum {
    /**
     * <pre>
     * Assume that incoming connections have already been resolved (to a
     * specific destination IP address). Such connections are typically
     * routed via the proxy using mechanisms such as IP table REDIRECT/
     * eBPF. After performing any routing related transformations, the
     * proxy will forward the connection to the IP address to which the
     * connection was bound.
     * </pre>
     *
     * <code>NONE = 0;</code>
     */
    NONE(0),
    /**
     * <pre>
     * Use the static IP addresses specified in endpoints (see below) as the
     * backing instances associated with the service.
     * </pre>
     *
     * <code>STATIC = 1;</code>
     */
    STATIC(1),
    /**
     * <pre>
     * Attempt to resolve the IP address by querying the ambient DNS,
     * during request processing. If no endpoints are specified, the proxy
     * will resolve the DNS address specified in the hosts field, if
     * wildcards are not used. If endpoints are specified, the DNS
     * addresses specified in the endpoints will be resolved to determine
     * the destination IP address.  DNS resolution cannot be used with Unix
     * domain socket endpoints.
     * </pre>
     *
     * <code>DNS = 2;</code>
     */
    DNS(2),
    UNRECOGNIZED(-1),
    ;

    /**
     * <pre>
     * Assume that incoming connections have already been resolved (to a
     * specific destination IP address). Such connections are typically
     * routed via the proxy using mechanisms such as IP table REDIRECT/
     * eBPF. After performing any routing related transformations, the
     * proxy will forward the connection to the IP address to which the
     * connection was bound.
     * </pre>
     *
     * <code>NONE = 0;</code>
     */
    public static final int NONE_VALUE = 0;
    /**
     * <pre>
     * Use the static IP addresses specified in endpoints (see below) as the
     * backing instances associated with the service.
     * </pre>
     *
     * <code>STATIC = 1;</code>
     */
    public static final int STATIC_VALUE = 1;
    /**
     * <pre>
     * Attempt to resolve the IP address by querying the ambient DNS,
     * during request processing. If no endpoints are specified, the proxy
     * will resolve the DNS address specified in the hosts field, if
     * wildcards are not used. If endpoints are specified, the DNS
     * addresses specified in the endpoints will be resolved to determine
     * the destination IP address.  DNS resolution cannot be used with Unix
     * domain socket endpoints.
     * </pre>
     *
     * <code>DNS = 2;</code>
     */
    public static final int DNS_VALUE = 2;


    public final int getNumber() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalArgumentException(
            "Can't get the number of an unknown enum value.");
      }
      return value;
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     * @deprecated Use {@link #forNumber(int)} instead.
     */
    @java.lang.Deprecated
    public static Resolution valueOf(int value) {
      return forNumber(value);
    }

    /**
     * @param value The numeric wire value of the corresponding enum entry.
     * @return The enum associated with the given numeric wire value.
     */
    public static Resolution forNumber(int value) {
      switch (value) {
        case 0: return NONE;
        case 1: return STATIC;
        case 2: return DNS;
        default: return null;
      }
    }

    public static com.google.protobuf.Internal.EnumLiteMap<Resolution>
        internalGetValueMap() {
      return internalValueMap;
    }
    private static final com.google.protobuf.Internal.EnumLiteMap<
        Resolution> internalValueMap =
          new com.google.protobuf.Internal.EnumLiteMap<Resolution>() {
            public Resolution findValueByNumber(int number) {
              return Resolution.forNumber(number);
            }
          };

    public final com.google.protobuf.Descriptors.EnumValueDescriptor
        getValueDescriptor() {
      if (this == UNRECOGNIZED) {
        throw new java.lang.IllegalStateException(
            "Can't get the descriptor of an unrecognized enum value.");
      }
      return getDescriptor().getValues().get(ordinal());
    }
    public final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptorForType() {
      return getDescriptor();
    }
    public static final com.google.protobuf.Descriptors.EnumDescriptor
        getDescriptor() {
      return io.ourea.adapter.model.istio.ServiceEntry.getDescriptor().getEnumTypes().get(1);
    }

    private static final Resolution[] VALUES = values();

    public static Resolution valueOf(
        com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
      if (desc.getType() != getDescriptor()) {
        throw new java.lang.IllegalArgumentException(
          "EnumValueDescriptor is not for this type.");
      }
      if (desc.getIndex() == -1) {
        return UNRECOGNIZED;
      }
      return VALUES[desc.getIndex()];
    }

    private final int value;

    private Resolution(int value) {
      this.value = value;
    }

    // @@protoc_insertion_point(enum_scope:istio.networking.v1alpha3.ServiceEntry.Resolution)
  }

  public static final int HOSTS_FIELD_NUMBER = 1;
  private com.google.protobuf.LazyStringList hosts_;
  /**
   * <pre>
   * The hosts associated with the ServiceEntry. Could be a DNS
   * name with wildcard prefix.
   * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
   * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
   * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
   * will be matched against the hosts field.
   * **NOTE 1:** When resolution is set to type DNS and no endpoints
   * are specified, the host field will be used as the DNS name of the
   * endpoint to route traffic to.
   * **NOTE 2:** If the hostname matches with the name of a service
   * from another service registry such as Kubernetes that also
   * supplies its own set of endpoints, the ServiceEntry will be
   * treated as a decorator of the existing Kubernetes
   * service. Properties in the service entry will be added to the
   * Kubernetes service if applicable. Currently, the only the
   * following additional properties will be considered by `istiod`:
   * 1. subjectAltNames: In addition to verifying the SANs of the
   *    service accounts associated with the pods of the service, the
   *    SANs specified here will also be verified.
   * </pre>
   *
   * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return A list containing the hosts.
   */
  public com.google.protobuf.ProtocolStringList
      getHostsList() {
    return hosts_;
  }
  /**
   * <pre>
   * The hosts associated with the ServiceEntry. Could be a DNS
   * name with wildcard prefix.
   * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
   * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
   * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
   * will be matched against the hosts field.
   * **NOTE 1:** When resolution is set to type DNS and no endpoints
   * are specified, the host field will be used as the DNS name of the
   * endpoint to route traffic to.
   * **NOTE 2:** If the hostname matches with the name of a service
   * from another service registry such as Kubernetes that also
   * supplies its own set of endpoints, the ServiceEntry will be
   * treated as a decorator of the existing Kubernetes
   * service. Properties in the service entry will be added to the
   * Kubernetes service if applicable. Currently, the only the
   * following additional properties will be considered by `istiod`:
   * 1. subjectAltNames: In addition to verifying the SANs of the
   *    service accounts associated with the pods of the service, the
   *    SANs specified here will also be verified.
   * </pre>
   *
   * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The count of hosts.
   */
  public int getHostsCount() {
    return hosts_.size();
  }
  /**
   * <pre>
   * The hosts associated with the ServiceEntry. Could be a DNS
   * name with wildcard prefix.
   * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
   * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
   * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
   * will be matched against the hosts field.
   * **NOTE 1:** When resolution is set to type DNS and no endpoints
   * are specified, the host field will be used as the DNS name of the
   * endpoint to route traffic to.
   * **NOTE 2:** If the hostname matches with the name of a service
   * from another service registry such as Kubernetes that also
   * supplies its own set of endpoints, the ServiceEntry will be
   * treated as a decorator of the existing Kubernetes
   * service. Properties in the service entry will be added to the
   * Kubernetes service if applicable. Currently, the only the
   * following additional properties will be considered by `istiod`:
   * 1. subjectAltNames: In addition to verifying the SANs of the
   *    service accounts associated with the pods of the service, the
   *    SANs specified here will also be verified.
   * </pre>
   *
   * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @param index The index of the element to return.
   * @return The hosts at the given index.
   */
  public java.lang.String getHosts(int index) {
    return hosts_.get(index);
  }
  /**
   * <pre>
   * The hosts associated with the ServiceEntry. Could be a DNS
   * name with wildcard prefix.
   * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
   * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
   * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
   * will be matched against the hosts field.
   * **NOTE 1:** When resolution is set to type DNS and no endpoints
   * are specified, the host field will be used as the DNS name of the
   * endpoint to route traffic to.
   * **NOTE 2:** If the hostname matches with the name of a service
   * from another service registry such as Kubernetes that also
   * supplies its own set of endpoints, the ServiceEntry will be
   * treated as a decorator of the existing Kubernetes
   * service. Properties in the service entry will be added to the
   * Kubernetes service if applicable. Currently, the only the
   * following additional properties will be considered by `istiod`:
   * 1. subjectAltNames: In addition to verifying the SANs of the
   *    service accounts associated with the pods of the service, the
   *    SANs specified here will also be verified.
   * </pre>
   *
   * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
   * @param index The index of the value to return.
   * @return The bytes of the hosts at the given index.
   */
  public com.google.protobuf.ByteString
      getHostsBytes(int index) {
    return hosts_.getByteString(index);
  }

  public static final int ADDRESSES_FIELD_NUMBER = 2;
  private com.google.protobuf.LazyStringList addresses_;
  /**
   * <pre>
   * The virtual IP addresses associated with the service. Could be CIDR
   * prefix. For HTTP traffic, generated route configurations will include http route
   * domains for both the `addresses` and `hosts` field values and the destination will
   * be identified based on the HTTP Host/Authority header.
   * If one or more IP addresses are specified,
   * the incoming traffic will be identified as belonging to this service
   * if the destination IP matches the IP/CIDRs specified in the addresses
   * field. If the Addresses field is empty, traffic will be identified
   * solely based on the destination port. In such scenarios, the port on
   * which the service is being accessed must not be shared by any other
   * service in the mesh. In other words, the sidecar will behave as a
   * simple TCP proxy, forwarding incoming traffic on a specified port to
   * the specified destination endpoint IP/host. Unix domain socket
   * addresses are not supported in this field.
   * </pre>
   *
   * <code>repeated string addresses = 2;</code>
   * @return A list containing the addresses.
   */
  public com.google.protobuf.ProtocolStringList
      getAddressesList() {
    return addresses_;
  }
  /**
   * <pre>
   * The virtual IP addresses associated with the service. Could be CIDR
   * prefix. For HTTP traffic, generated route configurations will include http route
   * domains for both the `addresses` and `hosts` field values and the destination will
   * be identified based on the HTTP Host/Authority header.
   * If one or more IP addresses are specified,
   * the incoming traffic will be identified as belonging to this service
   * if the destination IP matches the IP/CIDRs specified in the addresses
   * field. If the Addresses field is empty, traffic will be identified
   * solely based on the destination port. In such scenarios, the port on
   * which the service is being accessed must not be shared by any other
   * service in the mesh. In other words, the sidecar will behave as a
   * simple TCP proxy, forwarding incoming traffic on a specified port to
   * the specified destination endpoint IP/host. Unix domain socket
   * addresses are not supported in this field.
   * </pre>
   *
   * <code>repeated string addresses = 2;</code>
   * @return The count of addresses.
   */
  public int getAddressesCount() {
    return addresses_.size();
  }
  /**
   * <pre>
   * The virtual IP addresses associated with the service. Could be CIDR
   * prefix. For HTTP traffic, generated route configurations will include http route
   * domains for both the `addresses` and `hosts` field values and the destination will
   * be identified based on the HTTP Host/Authority header.
   * If one or more IP addresses are specified,
   * the incoming traffic will be identified as belonging to this service
   * if the destination IP matches the IP/CIDRs specified in the addresses
   * field. If the Addresses field is empty, traffic will be identified
   * solely based on the destination port. In such scenarios, the port on
   * which the service is being accessed must not be shared by any other
   * service in the mesh. In other words, the sidecar will behave as a
   * simple TCP proxy, forwarding incoming traffic on a specified port to
   * the specified destination endpoint IP/host. Unix domain socket
   * addresses are not supported in this field.
   * </pre>
   *
   * <code>repeated string addresses = 2;</code>
   * @param index The index of the element to return.
   * @return The addresses at the given index.
   */
  public java.lang.String getAddresses(int index) {
    return addresses_.get(index);
  }
  /**
   * <pre>
   * The virtual IP addresses associated with the service. Could be CIDR
   * prefix. For HTTP traffic, generated route configurations will include http route
   * domains for both the `addresses` and `hosts` field values and the destination will
   * be identified based on the HTTP Host/Authority header.
   * If one or more IP addresses are specified,
   * the incoming traffic will be identified as belonging to this service
   * if the destination IP matches the IP/CIDRs specified in the addresses
   * field. If the Addresses field is empty, traffic will be identified
   * solely based on the destination port. In such scenarios, the port on
   * which the service is being accessed must not be shared by any other
   * service in the mesh. In other words, the sidecar will behave as a
   * simple TCP proxy, forwarding incoming traffic on a specified port to
   * the specified destination endpoint IP/host. Unix domain socket
   * addresses are not supported in this field.
   * </pre>
   *
   * <code>repeated string addresses = 2;</code>
   * @param index The index of the value to return.
   * @return The bytes of the addresses at the given index.
   */
  public com.google.protobuf.ByteString
      getAddressesBytes(int index) {
    return addresses_.getByteString(index);
  }

  public static final int PORTS_FIELD_NUMBER = 3;
  private java.util.List<io.ourea.adapter.model.Port> ports_;
  /**
   * <pre>
   * The ports associated with the external service. If the
   * Endpoints are Unix domain socket addresses, there must be exactly one
   * port.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  @java.lang.Override
  public java.util.List<io.ourea.adapter.model.Port> getPortsList() {
    return ports_;
  }
  /**
   * <pre>
   * The ports associated with the external service. If the
   * Endpoints are Unix domain socket addresses, there must be exactly one
   * port.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.ourea.adapter.model.PortOrBuilder> 
      getPortsOrBuilderList() {
    return ports_;
  }
  /**
   * <pre>
   * The ports associated with the external service. If the
   * Endpoints are Unix domain socket addresses, there must be exactly one
   * port.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  @java.lang.Override
  public int getPortsCount() {
    return ports_.size();
  }
  /**
   * <pre>
   * The ports associated with the external service. If the
   * Endpoints are Unix domain socket addresses, there must be exactly one
   * port.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  @java.lang.Override
  public io.ourea.adapter.model.Port getPorts(int index) {
    return ports_.get(index);
  }
  /**
   * <pre>
   * The ports associated with the external service. If the
   * Endpoints are Unix domain socket addresses, there must be exactly one
   * port.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
   */
  @java.lang.Override
  public io.ourea.adapter.model.PortOrBuilder getPortsOrBuilder(
      int index) {
    return ports_.get(index);
  }

  public static final int LOCATION_FIELD_NUMBER = 4;
  private int location_;
  /**
   * <pre>
   * Specify whether the service should be considered external to the mesh
   * or part of the mesh.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
   * @return The enum numeric value on the wire for location.
   */
  @java.lang.Override public int getLocationValue() {
    return location_;
  }
  /**
   * <pre>
   * Specify whether the service should be considered external to the mesh
   * or part of the mesh.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
   * @return The location.
   */
  @java.lang.Override public io.ourea.adapter.model.istio.ServiceEntry.Location getLocation() {
    @SuppressWarnings("deprecation")
    io.ourea.adapter.model.istio.ServiceEntry.Location result = io.ourea.adapter.model.istio.ServiceEntry.Location.valueOf(location_);
    return result == null ? io.ourea.adapter.model.istio.ServiceEntry.Location.UNRECOGNIZED : result;
  }

  public static final int RESOLUTION_FIELD_NUMBER = 5;
  private int resolution_;
  /**
   * <pre>
   * Service discovery mode for the hosts. Care must be taken
   * when setting the resolution mode to NONE for a TCP port without
   * accompanying IP addresses. In such cases, traffic to any IP on
   * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The enum numeric value on the wire for resolution.
   */
  @java.lang.Override public int getResolutionValue() {
    return resolution_;
  }
  /**
   * <pre>
   * Service discovery mode for the hosts. Care must be taken
   * when setting the resolution mode to NONE for a TCP port without
   * accompanying IP addresses. In such cases, traffic to any IP on
   * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
   * @return The resolution.
   */
  @java.lang.Override public io.ourea.adapter.model.istio.ServiceEntry.Resolution getResolution() {
    @SuppressWarnings("deprecation")
    io.ourea.adapter.model.istio.ServiceEntry.Resolution result = io.ourea.adapter.model.istio.ServiceEntry.Resolution.valueOf(resolution_);
    return result == null ? io.ourea.adapter.model.istio.ServiceEntry.Resolution.UNRECOGNIZED : result;
  }

  public static final int ENDPOINTS_FIELD_NUMBER = 6;
  private java.util.List<io.ourea.adapter.model.istio.WorkloadEntry> endpoints_;
  /**
   * <pre>
   * One or more endpoints associated with the service. Only one of
   * `endpoints` or `workloadSelector` can be specified.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
   */
  @java.lang.Override
  public java.util.List<io.ourea.adapter.model.istio.WorkloadEntry> getEndpointsList() {
    return endpoints_;
  }
  /**
   * <pre>
   * One or more endpoints associated with the service. Only one of
   * `endpoints` or `workloadSelector` can be specified.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
   */
  @java.lang.Override
  public java.util.List<? extends io.ourea.adapter.model.istio.WorkloadEntryOrBuilder> 
      getEndpointsOrBuilderList() {
    return endpoints_;
  }
  /**
   * <pre>
   * One or more endpoints associated with the service. Only one of
   * `endpoints` or `workloadSelector` can be specified.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
   */
  @java.lang.Override
  public int getEndpointsCount() {
    return endpoints_.size();
  }
  /**
   * <pre>
   * One or more endpoints associated with the service. Only one of
   * `endpoints` or `workloadSelector` can be specified.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
   */
  @java.lang.Override
  public io.ourea.adapter.model.istio.WorkloadEntry getEndpoints(int index) {
    return endpoints_.get(index);
  }
  /**
   * <pre>
   * One or more endpoints associated with the service. Only one of
   * `endpoints` or `workloadSelector` can be specified.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
   */
  @java.lang.Override
  public io.ourea.adapter.model.istio.WorkloadEntryOrBuilder getEndpointsOrBuilder(
      int index) {
    return endpoints_.get(index);
  }

  public static final int WORKLOAD_SELECTOR_FIELD_NUMBER = 9;
  private io.ourea.adapter.model.istio.WorkloadSelector workloadSelector_;
  /**
   * <pre>
   * Applicable only for MESH_INTERNAL services. Only one of
   * `endpoints` or `workloadSelector` can be specified. Selects one
   * or more Kubernetes pods or VM workloads (specified using
   * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
   * representing the VMs should be defined in the same namespace as
   * the ServiceEntry.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
   * @return Whether the workloadSelector field is set.
   */
  @java.lang.Override
  public boolean hasWorkloadSelector() {
    return workloadSelector_ != null;
  }
  /**
   * <pre>
   * Applicable only for MESH_INTERNAL services. Only one of
   * `endpoints` or `workloadSelector` can be specified. Selects one
   * or more Kubernetes pods or VM workloads (specified using
   * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
   * representing the VMs should be defined in the same namespace as
   * the ServiceEntry.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
   * @return The workloadSelector.
   */
  @java.lang.Override
  public io.ourea.adapter.model.istio.WorkloadSelector getWorkloadSelector() {
    return workloadSelector_ == null ? io.ourea.adapter.model.istio.WorkloadSelector.getDefaultInstance() : workloadSelector_;
  }
  /**
   * <pre>
   * Applicable only for MESH_INTERNAL services. Only one of
   * `endpoints` or `workloadSelector` can be specified. Selects one
   * or more Kubernetes pods or VM workloads (specified using
   * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
   * representing the VMs should be defined in the same namespace as
   * the ServiceEntry.
   * </pre>
   *
   * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
   */
  @java.lang.Override
  public io.ourea.adapter.model.istio.WorkloadSelectorOrBuilder getWorkloadSelectorOrBuilder() {
    return getWorkloadSelector();
  }

  public static final int EXPORT_TO_FIELD_NUMBER = 7;
  private com.google.protobuf.LazyStringList exportTo_;
  /**
   * <pre>
   * A list of namespaces to which this service is exported. Exporting a service
   * allows it to be used by sidecars, gateways and virtual services defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of services across
   * namespace boundaries.
   * If no namespaces are specified then the service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * For a Kubernetes Service, the equivalent effect can be achieved by setting
   * the annotation "networking.istio.io/exportTo" to a comma-separated list
   * of namespace names.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 7;</code>
   * @return A list containing the exportTo.
   */
  public com.google.protobuf.ProtocolStringList
      getExportToList() {
    return exportTo_;
  }
  /**
   * <pre>
   * A list of namespaces to which this service is exported. Exporting a service
   * allows it to be used by sidecars, gateways and virtual services defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of services across
   * namespace boundaries.
   * If no namespaces are specified then the service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * For a Kubernetes Service, the equivalent effect can be achieved by setting
   * the annotation "networking.istio.io/exportTo" to a comma-separated list
   * of namespace names.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 7;</code>
   * @return The count of exportTo.
   */
  public int getExportToCount() {
    return exportTo_.size();
  }
  /**
   * <pre>
   * A list of namespaces to which this service is exported. Exporting a service
   * allows it to be used by sidecars, gateways and virtual services defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of services across
   * namespace boundaries.
   * If no namespaces are specified then the service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * For a Kubernetes Service, the equivalent effect can be achieved by setting
   * the annotation "networking.istio.io/exportTo" to a comma-separated list
   * of namespace names.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 7;</code>
   * @param index The index of the element to return.
   * @return The exportTo at the given index.
   */
  public java.lang.String getExportTo(int index) {
    return exportTo_.get(index);
  }
  /**
   * <pre>
   * A list of namespaces to which this service is exported. Exporting a service
   * allows it to be used by sidecars, gateways and virtual services defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of services across
   * namespace boundaries.
   * If no namespaces are specified then the service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * For a Kubernetes Service, the equivalent effect can be achieved by setting
   * the annotation "networking.istio.io/exportTo" to a comma-separated list
   * of namespace names.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 7;</code>
   * @param index The index of the value to return.
   * @return The bytes of the exportTo at the given index.
   */
  public com.google.protobuf.ByteString
      getExportToBytes(int index) {
    return exportTo_.getByteString(index);
  }

  public static final int SUBJECT_ALT_NAMES_FIELD_NUMBER = 8;
  private com.google.protobuf.LazyStringList subjectAltNames_;
  /**
   * <pre>
   * If specified, the proxy will verify that the server certificate's
   * subject alternate name matches one of the specified values.
   * NOTE: When using the workloadEntry with workloadSelectors, the
   * service account specified in the workloadEntry will also be used
   * to derive the additional subject alternate names that should be
   * verified.
   * </pre>
   *
   * <code>repeated string subject_alt_names = 8;</code>
   * @return A list containing the subjectAltNames.
   */
  public com.google.protobuf.ProtocolStringList
      getSubjectAltNamesList() {
    return subjectAltNames_;
  }
  /**
   * <pre>
   * If specified, the proxy will verify that the server certificate's
   * subject alternate name matches one of the specified values.
   * NOTE: When using the workloadEntry with workloadSelectors, the
   * service account specified in the workloadEntry will also be used
   * to derive the additional subject alternate names that should be
   * verified.
   * </pre>
   *
   * <code>repeated string subject_alt_names = 8;</code>
   * @return The count of subjectAltNames.
   */
  public int getSubjectAltNamesCount() {
    return subjectAltNames_.size();
  }
  /**
   * <pre>
   * If specified, the proxy will verify that the server certificate's
   * subject alternate name matches one of the specified values.
   * NOTE: When using the workloadEntry with workloadSelectors, the
   * service account specified in the workloadEntry will also be used
   * to derive the additional subject alternate names that should be
   * verified.
   * </pre>
   *
   * <code>repeated string subject_alt_names = 8;</code>
   * @param index The index of the element to return.
   * @return The subjectAltNames at the given index.
   */
  public java.lang.String getSubjectAltNames(int index) {
    return subjectAltNames_.get(index);
  }
  /**
   * <pre>
   * If specified, the proxy will verify that the server certificate's
   * subject alternate name matches one of the specified values.
   * NOTE: When using the workloadEntry with workloadSelectors, the
   * service account specified in the workloadEntry will also be used
   * to derive the additional subject alternate names that should be
   * verified.
   * </pre>
   *
   * <code>repeated string subject_alt_names = 8;</code>
   * @param index The index of the value to return.
   * @return The bytes of the subjectAltNames at the given index.
   */
  public com.google.protobuf.ByteString
      getSubjectAltNamesBytes(int index) {
    return subjectAltNames_.getByteString(index);
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    for (int i = 0; i < hosts_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 1, hosts_.getRaw(i));
    }
    for (int i = 0; i < addresses_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 2, addresses_.getRaw(i));
    }
    for (int i = 0; i < ports_.size(); i++) {
      output.writeMessage(3, ports_.get(i));
    }
    if (location_ != io.ourea.adapter.model.istio.ServiceEntry.Location.MESH_EXTERNAL.getNumber()) {
      output.writeEnum(4, location_);
    }
    if (resolution_ != io.ourea.adapter.model.istio.ServiceEntry.Resolution.NONE.getNumber()) {
      output.writeEnum(5, resolution_);
    }
    for (int i = 0; i < endpoints_.size(); i++) {
      output.writeMessage(6, endpoints_.get(i));
    }
    for (int i = 0; i < exportTo_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 7, exportTo_.getRaw(i));
    }
    for (int i = 0; i < subjectAltNames_.size(); i++) {
      com.google.protobuf.GeneratedMessageV3.writeString(output, 8, subjectAltNames_.getRaw(i));
    }
    if (workloadSelector_ != null) {
      output.writeMessage(9, getWorkloadSelector());
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    {
      int dataSize = 0;
      for (int i = 0; i < hosts_.size(); i++) {
        dataSize += computeStringSizeNoTag(hosts_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getHostsList().size();
    }
    {
      int dataSize = 0;
      for (int i = 0; i < addresses_.size(); i++) {
        dataSize += computeStringSizeNoTag(addresses_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getAddressesList().size();
    }
    for (int i = 0; i < ports_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(3, ports_.get(i));
    }
    if (location_ != io.ourea.adapter.model.istio.ServiceEntry.Location.MESH_EXTERNAL.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(4, location_);
    }
    if (resolution_ != io.ourea.adapter.model.istio.ServiceEntry.Resolution.NONE.getNumber()) {
      size += com.google.protobuf.CodedOutputStream
        .computeEnumSize(5, resolution_);
    }
    for (int i = 0; i < endpoints_.size(); i++) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(6, endpoints_.get(i));
    }
    {
      int dataSize = 0;
      for (int i = 0; i < exportTo_.size(); i++) {
        dataSize += computeStringSizeNoTag(exportTo_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getExportToList().size();
    }
    {
      int dataSize = 0;
      for (int i = 0; i < subjectAltNames_.size(); i++) {
        dataSize += computeStringSizeNoTag(subjectAltNames_.getRaw(i));
      }
      size += dataSize;
      size += 1 * getSubjectAltNamesList().size();
    }
    if (workloadSelector_ != null) {
      size += com.google.protobuf.CodedOutputStream
        .computeMessageSize(9, getWorkloadSelector());
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof io.ourea.adapter.model.istio.ServiceEntry)) {
      return super.equals(obj);
    }
    io.ourea.adapter.model.istio.ServiceEntry other = (io.ourea.adapter.model.istio.ServiceEntry) obj;

    if (!getHostsList()
        .equals(other.getHostsList())) return false;
    if (!getAddressesList()
        .equals(other.getAddressesList())) return false;
    if (!getPortsList()
        .equals(other.getPortsList())) return false;
    if (location_ != other.location_) return false;
    if (resolution_ != other.resolution_) return false;
    if (!getEndpointsList()
        .equals(other.getEndpointsList())) return false;
    if (hasWorkloadSelector() != other.hasWorkloadSelector()) return false;
    if (hasWorkloadSelector()) {
      if (!getWorkloadSelector()
          .equals(other.getWorkloadSelector())) return false;
    }
    if (!getExportToList()
        .equals(other.getExportToList())) return false;
    if (!getSubjectAltNamesList()
        .equals(other.getSubjectAltNamesList())) return false;
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (getHostsCount() > 0) {
      hash = (37 * hash) + HOSTS_FIELD_NUMBER;
      hash = (53 * hash) + getHostsList().hashCode();
    }
    if (getAddressesCount() > 0) {
      hash = (37 * hash) + ADDRESSES_FIELD_NUMBER;
      hash = (53 * hash) + getAddressesList().hashCode();
    }
    if (getPortsCount() > 0) {
      hash = (37 * hash) + PORTS_FIELD_NUMBER;
      hash = (53 * hash) + getPortsList().hashCode();
    }
    hash = (37 * hash) + LOCATION_FIELD_NUMBER;
    hash = (53 * hash) + location_;
    hash = (37 * hash) + RESOLUTION_FIELD_NUMBER;
    hash = (53 * hash) + resolution_;
    if (getEndpointsCount() > 0) {
      hash = (37 * hash) + ENDPOINTS_FIELD_NUMBER;
      hash = (53 * hash) + getEndpointsList().hashCode();
    }
    if (hasWorkloadSelector()) {
      hash = (37 * hash) + WORKLOAD_SELECTOR_FIELD_NUMBER;
      hash = (53 * hash) + getWorkloadSelector().hashCode();
    }
    if (getExportToCount() > 0) {
      hash = (37 * hash) + EXPORT_TO_FIELD_NUMBER;
      hash = (53 * hash) + getExportToList().hashCode();
    }
    if (getSubjectAltNamesCount() > 0) {
      hash = (37 * hash) + SUBJECT_ALT_NAMES_FIELD_NUMBER;
      hash = (53 * hash) + getSubjectAltNamesList().hashCode();
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static io.ourea.adapter.model.istio.ServiceEntry parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(io.ourea.adapter.model.istio.ServiceEntry prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * ServiceEntry enables adding additional entries into Istio's internal
   * service registry.
   * &lt;!-- crd generation tags
   * +cue-gen:ServiceEntry:groupName:networking.istio.io
   * +cue-gen:ServiceEntry:version:v1alpha3
   * +cue-gen:ServiceEntry:storageVersion
   * +cue-gen:ServiceEntry:annotations:helm.sh/resource-policy=keep
   * +cue-gen:ServiceEntry:labels:app=istio-pilot,chart=istio,heritage=Tiller,release=istio
   * +cue-gen:ServiceEntry:subresource:status
   * +cue-gen:ServiceEntry:scope:Namespaced
   * +cue-gen:ServiceEntry:resource:categories=istio-io,networking-istio-io,shortNames=se,plural=serviceentries
   * +cue-gen:ServiceEntry:printerColumn:name=Hosts,type=string,JSONPath=.spec.hosts,description="The hosts associated with the ServiceEntry"
   * +cue-gen:ServiceEntry:printerColumn:name=Location,type=string,JSONPath=.spec.location,description="Whether the service is external to the
   * mesh or part of the mesh (MESH_EXTERNAL or MESH_INTERNAL)"
   * +cue-gen:ServiceEntry:printerColumn:name=Resolution,type=string,JSONPath=.spec.resolution,description="Service discovery mode for the hosts
   * (NONE, STATIC, or DNS)"
   * +cue-gen:ServiceEntry:printerColumn:name=Age,type=date,JSONPath=.metadata.creationTimestamp,description="CreationTimestamp is a timestamp
   * representing the server time when this object was created. It is not guaranteed to be set in happens-before order across separate operations.
   * Clients may not set this value. It is represented in RFC3339 form and is in UTC.
   * Populated by the system. Read-only. Null for lists. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata"
   * --&gt;
   * &lt;!-- go code generation tags
   * +kubetype-gen
   * +kubetype-gen:groupVersion=networking.istio.io/v1alpha3
   * +genclient
   * +k8s:deepcopy-gen=true
   * --&gt;
   * </pre>
   *
   * Protobuf type {@code istio.networking.v1alpha3.ServiceEntry}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:istio.networking.v1alpha3.ServiceEntry)
      io.ourea.adapter.model.istio.ServiceEntryOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.ourea.adapter.model.istio.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.ourea.adapter.model.istio.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.ourea.adapter.model.istio.ServiceEntry.class, io.ourea.adapter.model.istio.ServiceEntry.Builder.class);
    }

    // Construct using io.ourea.adapter.model.istio.ServiceEntry.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
        getPortsFieldBuilder();
        getEndpointsFieldBuilder();
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000001);
      addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000002);
      if (portsBuilder_ == null) {
        ports_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
      } else {
        portsBuilder_.clear();
      }
      location_ = 0;

      resolution_ = 0;

      if (endpointsBuilder_ == null) {
        endpoints_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
      } else {
        endpointsBuilder_.clear();
      }
      if (workloadSelectorBuilder_ == null) {
        workloadSelector_ = null;
      } else {
        workloadSelector_ = null;
        workloadSelectorBuilder_ = null;
      }
      exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000010);
      subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000020);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return io.ourea.adapter.model.istio.ServiceEntryOuterClass.internal_static_istio_networking_v1alpha3_ServiceEntry_descriptor;
    }

    @java.lang.Override
    public io.ourea.adapter.model.istio.ServiceEntry getDefaultInstanceForType() {
      return io.ourea.adapter.model.istio.ServiceEntry.getDefaultInstance();
    }

    @java.lang.Override
    public io.ourea.adapter.model.istio.ServiceEntry build() {
      io.ourea.adapter.model.istio.ServiceEntry result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public io.ourea.adapter.model.istio.ServiceEntry buildPartial() {
      io.ourea.adapter.model.istio.ServiceEntry result = new io.ourea.adapter.model.istio.ServiceEntry(this);
      int from_bitField0_ = bitField0_;
      if (((bitField0_ & 0x00000001) != 0)) {
        hosts_ = hosts_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000001);
      }
      result.hosts_ = hosts_;
      if (((bitField0_ & 0x00000002) != 0)) {
        addresses_ = addresses_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000002);
      }
      result.addresses_ = addresses_;
      if (portsBuilder_ == null) {
        if (((bitField0_ & 0x00000004) != 0)) {
          ports_ = java.util.Collections.unmodifiableList(ports_);
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.ports_ = ports_;
      } else {
        result.ports_ = portsBuilder_.build();
      }
      result.location_ = location_;
      result.resolution_ = resolution_;
      if (endpointsBuilder_ == null) {
        if (((bitField0_ & 0x00000008) != 0)) {
          endpoints_ = java.util.Collections.unmodifiableList(endpoints_);
          bitField0_ = (bitField0_ & ~0x00000008);
        }
        result.endpoints_ = endpoints_;
      } else {
        result.endpoints_ = endpointsBuilder_.build();
      }
      if (workloadSelectorBuilder_ == null) {
        result.workloadSelector_ = workloadSelector_;
      } else {
        result.workloadSelector_ = workloadSelectorBuilder_.build();
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        exportTo_ = exportTo_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000010);
      }
      result.exportTo_ = exportTo_;
      if (((bitField0_ & 0x00000020) != 0)) {
        subjectAltNames_ = subjectAltNames_.getUnmodifiableView();
        bitField0_ = (bitField0_ & ~0x00000020);
      }
      result.subjectAltNames_ = subjectAltNames_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof io.ourea.adapter.model.istio.ServiceEntry) {
        return mergeFrom((io.ourea.adapter.model.istio.ServiceEntry)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(io.ourea.adapter.model.istio.ServiceEntry other) {
      if (other == io.ourea.adapter.model.istio.ServiceEntry.getDefaultInstance()) return this;
      if (!other.hosts_.isEmpty()) {
        if (hosts_.isEmpty()) {
          hosts_ = other.hosts_;
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          ensureHostsIsMutable();
          hosts_.addAll(other.hosts_);
        }
        onChanged();
      }
      if (!other.addresses_.isEmpty()) {
        if (addresses_.isEmpty()) {
          addresses_ = other.addresses_;
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          ensureAddressesIsMutable();
          addresses_.addAll(other.addresses_);
        }
        onChanged();
      }
      if (portsBuilder_ == null) {
        if (!other.ports_.isEmpty()) {
          if (ports_.isEmpty()) {
            ports_ = other.ports_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensurePortsIsMutable();
            ports_.addAll(other.ports_);
          }
          onChanged();
        }
      } else {
        if (!other.ports_.isEmpty()) {
          if (portsBuilder_.isEmpty()) {
            portsBuilder_.dispose();
            portsBuilder_ = null;
            ports_ = other.ports_;
            bitField0_ = (bitField0_ & ~0x00000004);
            portsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getPortsFieldBuilder() : null;
          } else {
            portsBuilder_.addAllMessages(other.ports_);
          }
        }
      }
      if (other.location_ != 0) {
        setLocationValue(other.getLocationValue());
      }
      if (other.resolution_ != 0) {
        setResolutionValue(other.getResolutionValue());
      }
      if (endpointsBuilder_ == null) {
        if (!other.endpoints_.isEmpty()) {
          if (endpoints_.isEmpty()) {
            endpoints_ = other.endpoints_;
            bitField0_ = (bitField0_ & ~0x00000008);
          } else {
            ensureEndpointsIsMutable();
            endpoints_.addAll(other.endpoints_);
          }
          onChanged();
        }
      } else {
        if (!other.endpoints_.isEmpty()) {
          if (endpointsBuilder_.isEmpty()) {
            endpointsBuilder_.dispose();
            endpointsBuilder_ = null;
            endpoints_ = other.endpoints_;
            bitField0_ = (bitField0_ & ~0x00000008);
            endpointsBuilder_ = 
              com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                 getEndpointsFieldBuilder() : null;
          } else {
            endpointsBuilder_.addAllMessages(other.endpoints_);
          }
        }
      }
      if (other.hasWorkloadSelector()) {
        mergeWorkloadSelector(other.getWorkloadSelector());
      }
      if (!other.exportTo_.isEmpty()) {
        if (exportTo_.isEmpty()) {
          exportTo_ = other.exportTo_;
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          ensureExportToIsMutable();
          exportTo_.addAll(other.exportTo_);
        }
        onChanged();
      }
      if (!other.subjectAltNames_.isEmpty()) {
        if (subjectAltNames_.isEmpty()) {
          subjectAltNames_ = other.subjectAltNames_;
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          ensureSubjectAltNamesIsMutable();
          subjectAltNames_.addAll(other.subjectAltNames_);
        }
        onChanged();
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      io.ourea.adapter.model.istio.ServiceEntry parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (io.ourea.adapter.model.istio.ServiceEntry) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private com.google.protobuf.LazyStringList hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureHostsIsMutable() {
      if (!((bitField0_ & 0x00000001) != 0)) {
        hosts_ = new com.google.protobuf.LazyStringArrayList(hosts_);
        bitField0_ |= 0x00000001;
       }
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return A list containing the hosts.
     */
    public com.google.protobuf.ProtocolStringList
        getHostsList() {
      return hosts_.getUnmodifiableView();
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The count of hosts.
     */
    public int getHostsCount() {
      return hosts_.size();
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index of the element to return.
     * @return The hosts at the given index.
     */
    public java.lang.String getHosts(int index) {
      return hosts_.get(index);
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index of the value to return.
     * @return The bytes of the hosts at the given index.
     */
    public com.google.protobuf.ByteString
        getHostsBytes(int index) {
      return hosts_.getByteString(index);
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param index The index to set the value at.
     * @param value The hosts to set.
     * @return This builder for chaining.
     */
    public Builder setHosts(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureHostsIsMutable();
      hosts_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param value The hosts to add.
     * @return This builder for chaining.
     */
    public Builder addHosts(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureHostsIsMutable();
      hosts_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param values The hosts to add.
     * @return This builder for chaining.
     */
    public Builder addAllHosts(
        java.lang.Iterable<java.lang.String> values) {
      ensureHostsIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, hosts_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return This builder for chaining.
     */
    public Builder clearHosts() {
      hosts_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000001);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The hosts associated with the ServiceEntry. Could be a DNS
     * name with wildcard prefix.
     * 1. The hosts field is used to select matching hosts in VirtualServices and DestinationRules.
     * 2. For HTTP traffic the HTTP Host/Authority header will be matched against the hosts field.
     * 3. For HTTPs or TLS traffic containing Server Name Indication (SNI), the SNI value
     * will be matched against the hosts field.
     * **NOTE 1:** When resolution is set to type DNS and no endpoints
     * are specified, the host field will be used as the DNS name of the
     * endpoint to route traffic to.
     * **NOTE 2:** If the hostname matches with the name of a service
     * from another service registry such as Kubernetes that also
     * supplies its own set of endpoints, the ServiceEntry will be
     * treated as a decorator of the existing Kubernetes
     * service. Properties in the service entry will be added to the
     * Kubernetes service if applicable. Currently, the only the
     * following additional properties will be considered by `istiod`:
     * 1. subjectAltNames: In addition to verifying the SANs of the
     *    service accounts associated with the pods of the service, the
     *    SANs specified here will also be verified.
     * </pre>
     *
     * <code>repeated string hosts = 1 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param value The bytes of the hosts to add.
     * @return This builder for chaining.
     */
    public Builder addHostsBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureHostsIsMutable();
      hosts_.add(value);
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureAddressesIsMutable() {
      if (!((bitField0_ & 0x00000002) != 0)) {
        addresses_ = new com.google.protobuf.LazyStringArrayList(addresses_);
        bitField0_ |= 0x00000002;
       }
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return A list containing the addresses.
     */
    public com.google.protobuf.ProtocolStringList
        getAddressesList() {
      return addresses_.getUnmodifiableView();
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return The count of addresses.
     */
    public int getAddressesCount() {
      return addresses_.size();
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index of the element to return.
     * @return The addresses at the given index.
     */
    public java.lang.String getAddresses(int index) {
      return addresses_.get(index);
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index of the value to return.
     * @return The bytes of the addresses at the given index.
     */
    public com.google.protobuf.ByteString
        getAddressesBytes(int index) {
      return addresses_.getByteString(index);
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param index The index to set the value at.
     * @param value The addresses to set.
     * @return This builder for chaining.
     */
    public Builder setAddresses(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAddressesIsMutable();
      addresses_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param value The addresses to add.
     * @return This builder for chaining.
     */
    public Builder addAddresses(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureAddressesIsMutable();
      addresses_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param values The addresses to add.
     * @return This builder for chaining.
     */
    public Builder addAllAddresses(
        java.lang.Iterable<java.lang.String> values) {
      ensureAddressesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, addresses_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearAddresses() {
      addresses_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000002);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The virtual IP addresses associated with the service. Could be CIDR
     * prefix. For HTTP traffic, generated route configurations will include http route
     * domains for both the `addresses` and `hosts` field values and the destination will
     * be identified based on the HTTP Host/Authority header.
     * If one or more IP addresses are specified,
     * the incoming traffic will be identified as belonging to this service
     * if the destination IP matches the IP/CIDRs specified in the addresses
     * field. If the Addresses field is empty, traffic will be identified
     * solely based on the destination port. In such scenarios, the port on
     * which the service is being accessed must not be shared by any other
     * service in the mesh. In other words, the sidecar will behave as a
     * simple TCP proxy, forwarding incoming traffic on a specified port to
     * the specified destination endpoint IP/host. Unix domain socket
     * addresses are not supported in this field.
     * </pre>
     *
     * <code>repeated string addresses = 2;</code>
     * @param value The bytes of the addresses to add.
     * @return This builder for chaining.
     */
    public Builder addAddressesBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureAddressesIsMutable();
      addresses_.add(value);
      onChanged();
      return this;
    }

    private java.util.List<io.ourea.adapter.model.Port> ports_ =
      java.util.Collections.emptyList();
    private void ensurePortsIsMutable() {
      if (!((bitField0_ & 0x00000004) != 0)) {
        ports_ = new java.util.ArrayList<io.ourea.adapter.model.Port>(ports_);
        bitField0_ |= 0x00000004;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.ourea.adapter.model.Port, io.ourea.adapter.model.Port.Builder, io.ourea.adapter.model.PortOrBuilder> portsBuilder_;

    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public java.util.List<io.ourea.adapter.model.Port> getPortsList() {
      if (portsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(ports_);
      } else {
        return portsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public int getPortsCount() {
      if (portsBuilder_ == null) {
        return ports_.size();
      } else {
        return portsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public io.ourea.adapter.model.Port getPorts(int index) {
      if (portsBuilder_ == null) {
        return ports_.get(index);
      } else {
        return portsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder setPorts(
        int index, io.ourea.adapter.model.Port value) {
      if (portsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePortsIsMutable();
        ports_.set(index, value);
        onChanged();
      } else {
        portsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder setPorts(
        int index, io.ourea.adapter.model.Port.Builder builderForValue) {
      if (portsBuilder_ == null) {
        ensurePortsIsMutable();
        ports_.set(index, builderForValue.build());
        onChanged();
      } else {
        portsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder addPorts(io.ourea.adapter.model.Port value) {
      if (portsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePortsIsMutable();
        ports_.add(value);
        onChanged();
      } else {
        portsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder addPorts(
        int index, io.ourea.adapter.model.Port value) {
      if (portsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensurePortsIsMutable();
        ports_.add(index, value);
        onChanged();
      } else {
        portsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder addPorts(
        io.ourea.adapter.model.Port.Builder builderForValue) {
      if (portsBuilder_ == null) {
        ensurePortsIsMutable();
        ports_.add(builderForValue.build());
        onChanged();
      } else {
        portsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder addPorts(
        int index, io.ourea.adapter.model.Port.Builder builderForValue) {
      if (portsBuilder_ == null) {
        ensurePortsIsMutable();
        ports_.add(index, builderForValue.build());
        onChanged();
      } else {
        portsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder addAllPorts(
        java.lang.Iterable<? extends io.ourea.adapter.model.Port> values) {
      if (portsBuilder_ == null) {
        ensurePortsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, ports_);
        onChanged();
      } else {
        portsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder clearPorts() {
      if (portsBuilder_ == null) {
        ports_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
      } else {
        portsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public Builder removePorts(int index) {
      if (portsBuilder_ == null) {
        ensurePortsIsMutable();
        ports_.remove(index);
        onChanged();
      } else {
        portsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public io.ourea.adapter.model.Port.Builder getPortsBuilder(
        int index) {
      return getPortsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public io.ourea.adapter.model.PortOrBuilder getPortsOrBuilder(
        int index) {
      if (portsBuilder_ == null) {
        return ports_.get(index);  } else {
        return portsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public java.util.List<? extends io.ourea.adapter.model.PortOrBuilder> 
         getPortsOrBuilderList() {
      if (portsBuilder_ != null) {
        return portsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(ports_);
      }
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public io.ourea.adapter.model.Port.Builder addPortsBuilder() {
      return getPortsFieldBuilder().addBuilder(
          io.ourea.adapter.model.Port.getDefaultInstance());
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public io.ourea.adapter.model.Port.Builder addPortsBuilder(
        int index) {
      return getPortsFieldBuilder().addBuilder(
          index, io.ourea.adapter.model.Port.getDefaultInstance());
    }
    /**
     * <pre>
     * The ports associated with the external service. If the
     * Endpoints are Unix domain socket addresses, there must be exactly one
     * port.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.Port ports = 3 [(.google.api.field_behavior) = REQUIRED];</code>
     */
    public java.util.List<io.ourea.adapter.model.Port.Builder> 
         getPortsBuilderList() {
      return getPortsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.ourea.adapter.model.Port, io.ourea.adapter.model.Port.Builder, io.ourea.adapter.model.PortOrBuilder> 
        getPortsFieldBuilder() {
      if (portsBuilder_ == null) {
        portsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.ourea.adapter.model.Port, io.ourea.adapter.model.Port.Builder, io.ourea.adapter.model.PortOrBuilder>(
                ports_,
                ((bitField0_ & 0x00000004) != 0),
                getParentForChildren(),
                isClean());
        ports_ = null;
      }
      return portsBuilder_;
    }

    private int location_ = 0;
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return The enum numeric value on the wire for location.
     */
    @java.lang.Override public int getLocationValue() {
      return location_;
    }
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @param value The enum numeric value on the wire for location to set.
     * @return This builder for chaining.
     */
    public Builder setLocationValue(int value) {
      
      location_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return The location.
     */
    @java.lang.Override
    public io.ourea.adapter.model.istio.ServiceEntry.Location getLocation() {
      @SuppressWarnings("deprecation")
      io.ourea.adapter.model.istio.ServiceEntry.Location result = io.ourea.adapter.model.istio.ServiceEntry.Location.valueOf(location_);
      return result == null ? io.ourea.adapter.model.istio.ServiceEntry.Location.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @param value The location to set.
     * @return This builder for chaining.
     */
    public Builder setLocation(io.ourea.adapter.model.istio.ServiceEntry.Location value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      location_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Specify whether the service should be considered external to the mesh
     * or part of the mesh.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Location location = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearLocation() {
      
      location_ = 0;
      onChanged();
      return this;
    }

    private int resolution_ = 0;
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The enum numeric value on the wire for resolution.
     */
    @java.lang.Override public int getResolutionValue() {
      return resolution_;
    }
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param value The enum numeric value on the wire for resolution to set.
     * @return This builder for chaining.
     */
    public Builder setResolutionValue(int value) {
      
      resolution_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return The resolution.
     */
    @java.lang.Override
    public io.ourea.adapter.model.istio.ServiceEntry.Resolution getResolution() {
      @SuppressWarnings("deprecation")
      io.ourea.adapter.model.istio.ServiceEntry.Resolution result = io.ourea.adapter.model.istio.ServiceEntry.Resolution.valueOf(resolution_);
      return result == null ? io.ourea.adapter.model.istio.ServiceEntry.Resolution.UNRECOGNIZED : result;
    }
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @param value The resolution to set.
     * @return This builder for chaining.
     */
    public Builder setResolution(io.ourea.adapter.model.istio.ServiceEntry.Resolution value) {
      if (value == null) {
        throw new NullPointerException();
      }
      
      resolution_ = value.getNumber();
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Service discovery mode for the hosts. Care must be taken
     * when setting the resolution mode to NONE for a TCP port without
     * accompanying IP addresses. In such cases, traffic to any IP on
     * said port will be allowed (i.e. `0.0.0.0:&lt;port&gt;`).
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.ServiceEntry.Resolution resolution = 5 [(.google.api.field_behavior) = REQUIRED];</code>
     * @return This builder for chaining.
     */
    public Builder clearResolution() {
      
      resolution_ = 0;
      onChanged();
      return this;
    }

    private java.util.List<io.ourea.adapter.model.istio.WorkloadEntry> endpoints_ =
      java.util.Collections.emptyList();
    private void ensureEndpointsIsMutable() {
      if (!((bitField0_ & 0x00000008) != 0)) {
        endpoints_ = new java.util.ArrayList<io.ourea.adapter.model.istio.WorkloadEntry>(endpoints_);
        bitField0_ |= 0x00000008;
       }
    }

    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.ourea.adapter.model.istio.WorkloadEntry, io.ourea.adapter.model.istio.WorkloadEntry.Builder, io.ourea.adapter.model.istio.WorkloadEntryOrBuilder> endpointsBuilder_;

    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public java.util.List<io.ourea.adapter.model.istio.WorkloadEntry> getEndpointsList() {
      if (endpointsBuilder_ == null) {
        return java.util.Collections.unmodifiableList(endpoints_);
      } else {
        return endpointsBuilder_.getMessageList();
      }
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public int getEndpointsCount() {
      if (endpointsBuilder_ == null) {
        return endpoints_.size();
      } else {
        return endpointsBuilder_.getCount();
      }
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadEntry getEndpoints(int index) {
      if (endpointsBuilder_ == null) {
        return endpoints_.get(index);
      } else {
        return endpointsBuilder_.getMessage(index);
      }
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder setEndpoints(
        int index, io.ourea.adapter.model.istio.WorkloadEntry value) {
      if (endpointsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEndpointsIsMutable();
        endpoints_.set(index, value);
        onChanged();
      } else {
        endpointsBuilder_.setMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder setEndpoints(
        int index, io.ourea.adapter.model.istio.WorkloadEntry.Builder builderForValue) {
      if (endpointsBuilder_ == null) {
        ensureEndpointsIsMutable();
        endpoints_.set(index, builderForValue.build());
        onChanged();
      } else {
        endpointsBuilder_.setMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder addEndpoints(io.ourea.adapter.model.istio.WorkloadEntry value) {
      if (endpointsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEndpointsIsMutable();
        endpoints_.add(value);
        onChanged();
      } else {
        endpointsBuilder_.addMessage(value);
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder addEndpoints(
        int index, io.ourea.adapter.model.istio.WorkloadEntry value) {
      if (endpointsBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureEndpointsIsMutable();
        endpoints_.add(index, value);
        onChanged();
      } else {
        endpointsBuilder_.addMessage(index, value);
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder addEndpoints(
        io.ourea.adapter.model.istio.WorkloadEntry.Builder builderForValue) {
      if (endpointsBuilder_ == null) {
        ensureEndpointsIsMutable();
        endpoints_.add(builderForValue.build());
        onChanged();
      } else {
        endpointsBuilder_.addMessage(builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder addEndpoints(
        int index, io.ourea.adapter.model.istio.WorkloadEntry.Builder builderForValue) {
      if (endpointsBuilder_ == null) {
        ensureEndpointsIsMutable();
        endpoints_.add(index, builderForValue.build());
        onChanged();
      } else {
        endpointsBuilder_.addMessage(index, builderForValue.build());
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder addAllEndpoints(
        java.lang.Iterable<? extends io.ourea.adapter.model.istio.WorkloadEntry> values) {
      if (endpointsBuilder_ == null) {
        ensureEndpointsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, endpoints_);
        onChanged();
      } else {
        endpointsBuilder_.addAllMessages(values);
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder clearEndpoints() {
      if (endpointsBuilder_ == null) {
        endpoints_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000008);
        onChanged();
      } else {
        endpointsBuilder_.clear();
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public Builder removeEndpoints(int index) {
      if (endpointsBuilder_ == null) {
        ensureEndpointsIsMutable();
        endpoints_.remove(index);
        onChanged();
      } else {
        endpointsBuilder_.remove(index);
      }
      return this;
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadEntry.Builder getEndpointsBuilder(
        int index) {
      return getEndpointsFieldBuilder().getBuilder(index);
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadEntryOrBuilder getEndpointsOrBuilder(
        int index) {
      if (endpointsBuilder_ == null) {
        return endpoints_.get(index);  } else {
        return endpointsBuilder_.getMessageOrBuilder(index);
      }
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public java.util.List<? extends io.ourea.adapter.model.istio.WorkloadEntryOrBuilder> 
         getEndpointsOrBuilderList() {
      if (endpointsBuilder_ != null) {
        return endpointsBuilder_.getMessageOrBuilderList();
      } else {
        return java.util.Collections.unmodifiableList(endpoints_);
      }
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadEntry.Builder addEndpointsBuilder() {
      return getEndpointsFieldBuilder().addBuilder(
          io.ourea.adapter.model.istio.WorkloadEntry.getDefaultInstance());
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadEntry.Builder addEndpointsBuilder(
        int index) {
      return getEndpointsFieldBuilder().addBuilder(
          index, io.ourea.adapter.model.istio.WorkloadEntry.getDefaultInstance());
    }
    /**
     * <pre>
     * One or more endpoints associated with the service. Only one of
     * `endpoints` or `workloadSelector` can be specified.
     * </pre>
     *
     * <code>repeated .istio.networking.v1alpha3.WorkloadEntry endpoints = 6;</code>
     */
    public java.util.List<io.ourea.adapter.model.istio.WorkloadEntry.Builder> 
         getEndpointsBuilderList() {
      return getEndpointsFieldBuilder().getBuilderList();
    }
    private com.google.protobuf.RepeatedFieldBuilderV3<
        io.ourea.adapter.model.istio.WorkloadEntry, io.ourea.adapter.model.istio.WorkloadEntry.Builder, io.ourea.adapter.model.istio.WorkloadEntryOrBuilder> 
        getEndpointsFieldBuilder() {
      if (endpointsBuilder_ == null) {
        endpointsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
            io.ourea.adapter.model.istio.WorkloadEntry, io.ourea.adapter.model.istio.WorkloadEntry.Builder, io.ourea.adapter.model.istio.WorkloadEntryOrBuilder>(
                endpoints_,
                ((bitField0_ & 0x00000008) != 0),
                getParentForChildren(),
                isClean());
        endpoints_ = null;
      }
      return endpointsBuilder_;
    }

    private io.ourea.adapter.model.istio.WorkloadSelector workloadSelector_;
    private com.google.protobuf.SingleFieldBuilderV3<
        io.ourea.adapter.model.istio.WorkloadSelector, io.ourea.adapter.model.istio.WorkloadSelector.Builder, io.ourea.adapter.model.istio.WorkloadSelectorOrBuilder> workloadSelectorBuilder_;
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     * @return Whether the workloadSelector field is set.
     */
    public boolean hasWorkloadSelector() {
      return workloadSelectorBuilder_ != null || workloadSelector_ != null;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     * @return The workloadSelector.
     */
    public io.ourea.adapter.model.istio.WorkloadSelector getWorkloadSelector() {
      if (workloadSelectorBuilder_ == null) {
        return workloadSelector_ == null ? io.ourea.adapter.model.istio.WorkloadSelector.getDefaultInstance() : workloadSelector_;
      } else {
        return workloadSelectorBuilder_.getMessage();
      }
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    public Builder setWorkloadSelector(io.ourea.adapter.model.istio.WorkloadSelector value) {
      if (workloadSelectorBuilder_ == null) {
        if (value == null) {
          throw new NullPointerException();
        }
        workloadSelector_ = value;
        onChanged();
      } else {
        workloadSelectorBuilder_.setMessage(value);
      }

      return this;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    public Builder setWorkloadSelector(
        io.ourea.adapter.model.istio.WorkloadSelector.Builder builderForValue) {
      if (workloadSelectorBuilder_ == null) {
        workloadSelector_ = builderForValue.build();
        onChanged();
      } else {
        workloadSelectorBuilder_.setMessage(builderForValue.build());
      }

      return this;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    public Builder mergeWorkloadSelector(io.ourea.adapter.model.istio.WorkloadSelector value) {
      if (workloadSelectorBuilder_ == null) {
        if (workloadSelector_ != null) {
          workloadSelector_ =
            io.ourea.adapter.model.istio.WorkloadSelector.newBuilder(workloadSelector_).mergeFrom(value).buildPartial();
        } else {
          workloadSelector_ = value;
        }
        onChanged();
      } else {
        workloadSelectorBuilder_.mergeFrom(value);
      }

      return this;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    public Builder clearWorkloadSelector() {
      if (workloadSelectorBuilder_ == null) {
        workloadSelector_ = null;
        onChanged();
      } else {
        workloadSelector_ = null;
        workloadSelectorBuilder_ = null;
      }

      return this;
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadSelector.Builder getWorkloadSelectorBuilder() {
      
      onChanged();
      return getWorkloadSelectorFieldBuilder().getBuilder();
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    public io.ourea.adapter.model.istio.WorkloadSelectorOrBuilder getWorkloadSelectorOrBuilder() {
      if (workloadSelectorBuilder_ != null) {
        return workloadSelectorBuilder_.getMessageOrBuilder();
      } else {
        return workloadSelector_ == null ?
            io.ourea.adapter.model.istio.WorkloadSelector.getDefaultInstance() : workloadSelector_;
      }
    }
    /**
     * <pre>
     * Applicable only for MESH_INTERNAL services. Only one of
     * `endpoints` or `workloadSelector` can be specified. Selects one
     * or more Kubernetes pods or VM workloads (specified using
     * `WorkloadEntry`) based on their labels. The `WorkloadEntry` object
     * representing the VMs should be defined in the same namespace as
     * the ServiceEntry.
     * </pre>
     *
     * <code>.istio.networking.v1alpha3.WorkloadSelector workload_selector = 9;</code>
     */
    private com.google.protobuf.SingleFieldBuilderV3<
        io.ourea.adapter.model.istio.WorkloadSelector, io.ourea.adapter.model.istio.WorkloadSelector.Builder, io.ourea.adapter.model.istio.WorkloadSelectorOrBuilder> 
        getWorkloadSelectorFieldBuilder() {
      if (workloadSelectorBuilder_ == null) {
        workloadSelectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
            io.ourea.adapter.model.istio.WorkloadSelector, io.ourea.adapter.model.istio.WorkloadSelector.Builder, io.ourea.adapter.model.istio.WorkloadSelectorOrBuilder>(
                getWorkloadSelector(),
                getParentForChildren(),
                isClean());
        workloadSelector_ = null;
      }
      return workloadSelectorBuilder_;
    }

    private com.google.protobuf.LazyStringList exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureExportToIsMutable() {
      if (!((bitField0_ & 0x00000010) != 0)) {
        exportTo_ = new com.google.protobuf.LazyStringArrayList(exportTo_);
        bitField0_ |= 0x00000010;
       }
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return A list containing the exportTo.
     */
    public com.google.protobuf.ProtocolStringList
        getExportToList() {
      return exportTo_.getUnmodifiableView();
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return The count of exportTo.
     */
    public int getExportToCount() {
      return exportTo_.size();
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index of the element to return.
     * @return The exportTo at the given index.
     */
    public java.lang.String getExportTo(int index) {
      return exportTo_.get(index);
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index of the value to return.
     * @return The bytes of the exportTo at the given index.
     */
    public com.google.protobuf.ByteString
        getExportToBytes(int index) {
      return exportTo_.getByteString(index);
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param index The index to set the value at.
     * @param value The exportTo to set.
     * @return This builder for chaining.
     */
    public Builder setExportTo(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureExportToIsMutable();
      exportTo_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param value The exportTo to add.
     * @return This builder for chaining.
     */
    public Builder addExportTo(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureExportToIsMutable();
      exportTo_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param values The exportTo to add.
     * @return This builder for chaining.
     */
    public Builder addAllExportTo(
        java.lang.Iterable<java.lang.String> values) {
      ensureExportToIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, exportTo_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearExportTo() {
      exportTo_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000010);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * A list of namespaces to which this service is exported. Exporting a service
     * allows it to be used by sidecars, gateways and virtual services defined in
     * other namespaces. This feature provides a mechanism for service owners
     * and mesh administrators to control the visibility of services across
     * namespace boundaries.
     * If no namespaces are specified then the service is exported to all
     * namespaces by default.
     * The value "." is reserved and defines an export to the same namespace that
     * the service is declared in. Similarly the value "*" is reserved and
     * defines an export to all namespaces.
     * For a Kubernetes Service, the equivalent effect can be achieved by setting
     * the annotation "networking.istio.io/exportTo" to a comma-separated list
     * of namespace names.
     * NOTE: in the current release, the `exportTo` value is restricted to
     * "." or "*" (i.e., the current namespace or all namespaces).
     * </pre>
     *
     * <code>repeated string export_to = 7;</code>
     * @param value The bytes of the exportTo to add.
     * @return This builder for chaining.
     */
    public Builder addExportToBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureExportToIsMutable();
      exportTo_.add(value);
      onChanged();
      return this;
    }

    private com.google.protobuf.LazyStringList subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    private void ensureSubjectAltNamesIsMutable() {
      if (!((bitField0_ & 0x00000020) != 0)) {
        subjectAltNames_ = new com.google.protobuf.LazyStringArrayList(subjectAltNames_);
        bitField0_ |= 0x00000020;
       }
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return A list containing the subjectAltNames.
     */
    public com.google.protobuf.ProtocolStringList
        getSubjectAltNamesList() {
      return subjectAltNames_.getUnmodifiableView();
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return The count of subjectAltNames.
     */
    public int getSubjectAltNamesCount() {
      return subjectAltNames_.size();
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index of the element to return.
     * @return The subjectAltNames at the given index.
     */
    public java.lang.String getSubjectAltNames(int index) {
      return subjectAltNames_.get(index);
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index of the value to return.
     * @return The bytes of the subjectAltNames at the given index.
     */
    public com.google.protobuf.ByteString
        getSubjectAltNamesBytes(int index) {
      return subjectAltNames_.getByteString(index);
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param index The index to set the value at.
     * @param value The subjectAltNames to set.
     * @return This builder for chaining.
     */
    public Builder setSubjectAltNames(
        int index, java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureSubjectAltNamesIsMutable();
      subjectAltNames_.set(index, value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param value The subjectAltNames to add.
     * @return This builder for chaining.
     */
    public Builder addSubjectAltNames(
        java.lang.String value) {
      if (value == null) {
    throw new NullPointerException();
  }
  ensureSubjectAltNamesIsMutable();
      subjectAltNames_.add(value);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param values The subjectAltNames to add.
     * @return This builder for chaining.
     */
    public Builder addAllSubjectAltNames(
        java.lang.Iterable<java.lang.String> values) {
      ensureSubjectAltNamesIsMutable();
      com.google.protobuf.AbstractMessageLite.Builder.addAll(
          values, subjectAltNames_);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearSubjectAltNames() {
      subjectAltNames_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      bitField0_ = (bitField0_ & ~0x00000020);
      onChanged();
      return this;
    }
    /**
     * <pre>
     * If specified, the proxy will verify that the server certificate's
     * subject alternate name matches one of the specified values.
     * NOTE: When using the workloadEntry with workloadSelectors, the
     * service account specified in the workloadEntry will also be used
     * to derive the additional subject alternate names that should be
     * verified.
     * </pre>
     *
     * <code>repeated string subject_alt_names = 8;</code>
     * @param value The bytes of the subjectAltNames to add.
     * @return This builder for chaining.
     */
    public Builder addSubjectAltNamesBytes(
        com.google.protobuf.ByteString value) {
      if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
      ensureSubjectAltNamesIsMutable();
      subjectAltNames_.add(value);
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:istio.networking.v1alpha3.ServiceEntry)
  }

  // @@protoc_insertion_point(class_scope:istio.networking.v1alpha3.ServiceEntry)
  private static final io.ourea.adapter.model.istio.ServiceEntry DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new io.ourea.adapter.model.istio.ServiceEntry();
  }

  public static io.ourea.adapter.model.istio.ServiceEntry getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  private static final com.google.protobuf.Parser<ServiceEntry>
      PARSER = new com.google.protobuf.AbstractParser<ServiceEntry>() {
    @java.lang.Override
    public ServiceEntry parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new ServiceEntry(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<ServiceEntry> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<ServiceEntry> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public io.ourea.adapter.model.istio.ServiceEntry getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

