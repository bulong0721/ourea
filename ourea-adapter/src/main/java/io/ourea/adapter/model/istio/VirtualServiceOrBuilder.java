// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: virtual_service.proto

package io.ourea.adapter.model.istio;

public interface VirtualServiceOrBuilder extends
    // @@protoc_insertion_point(interface_extends:istio.networking.v1alpha3.VirtualService)
    com.google.protobuf.MessageOrBuilder {

  /**
   * <pre>
   * The destination hosts to which traffic is being sent. Could
   * be a DNS name with wildcard prefix or an IP address.  Depending on the
   * platform, short-names can also be used instead of a FQDN (i.e. has no
   * dots in the name). In such a scenario, the FQDN of the host would be
   * derived based on the underlying platform.
   * A single VirtualService can be used to describe all the traffic
   * properties of the corresponding hosts, including those for multiple
   * HTTP and TCP ports. Alternatively, the traffic properties of a host
   * can be defined using more than one VirtualService, with certain
   * caveats. Refer to the
   * [Operations Guide](https://istio.io/docs/ops/best-practices/traffic-management/#split-virtual-services)
   * for details.
   * *Note for Kubernetes users*: When short names are used (e.g. "reviews"
   * instead of "reviews.default.svc.cluster.local"), Istio will interpret
   * the short name based on the namespace of the rule, not the service. A
   * rule in the "default" namespace containing a host "reviews" will be
   * interpreted as "reviews.default.svc.cluster.local", irrespective of
   * the actual namespace associated with the reviews service. _To avoid
   * potential misconfigurations, it is recommended to always use fully
   * qualified domain names over short names._
   * The hosts field applies to both HTTP and TCP services. Service inside
   * the mesh, i.e., those found in the service registry, must always be
   * referred to using their alphanumeric names. IP addresses are allowed
   * only for services defined via the Gateway.
   * *Note*: It must be empty for a delegate VirtualService.
   * </pre>
   *
   * <code>repeated string hosts = 1;</code>
   * @return A list containing the hosts.
   */
  java.util.List<java.lang.String>
      getHostsList();
  /**
   * <pre>
   * The destination hosts to which traffic is being sent. Could
   * be a DNS name with wildcard prefix or an IP address.  Depending on the
   * platform, short-names can also be used instead of a FQDN (i.e. has no
   * dots in the name). In such a scenario, the FQDN of the host would be
   * derived based on the underlying platform.
   * A single VirtualService can be used to describe all the traffic
   * properties of the corresponding hosts, including those for multiple
   * HTTP and TCP ports. Alternatively, the traffic properties of a host
   * can be defined using more than one VirtualService, with certain
   * caveats. Refer to the
   * [Operations Guide](https://istio.io/docs/ops/best-practices/traffic-management/#split-virtual-services)
   * for details.
   * *Note for Kubernetes users*: When short names are used (e.g. "reviews"
   * instead of "reviews.default.svc.cluster.local"), Istio will interpret
   * the short name based on the namespace of the rule, not the service. A
   * rule in the "default" namespace containing a host "reviews" will be
   * interpreted as "reviews.default.svc.cluster.local", irrespective of
   * the actual namespace associated with the reviews service. _To avoid
   * potential misconfigurations, it is recommended to always use fully
   * qualified domain names over short names._
   * The hosts field applies to both HTTP and TCP services. Service inside
   * the mesh, i.e., those found in the service registry, must always be
   * referred to using their alphanumeric names. IP addresses are allowed
   * only for services defined via the Gateway.
   * *Note*: It must be empty for a delegate VirtualService.
   * </pre>
   *
   * <code>repeated string hosts = 1;</code>
   * @return The count of hosts.
   */
  int getHostsCount();
  /**
   * <pre>
   * The destination hosts to which traffic is being sent. Could
   * be a DNS name with wildcard prefix or an IP address.  Depending on the
   * platform, short-names can also be used instead of a FQDN (i.e. has no
   * dots in the name). In such a scenario, the FQDN of the host would be
   * derived based on the underlying platform.
   * A single VirtualService can be used to describe all the traffic
   * properties of the corresponding hosts, including those for multiple
   * HTTP and TCP ports. Alternatively, the traffic properties of a host
   * can be defined using more than one VirtualService, with certain
   * caveats. Refer to the
   * [Operations Guide](https://istio.io/docs/ops/best-practices/traffic-management/#split-virtual-services)
   * for details.
   * *Note for Kubernetes users*: When short names are used (e.g. "reviews"
   * instead of "reviews.default.svc.cluster.local"), Istio will interpret
   * the short name based on the namespace of the rule, not the service. A
   * rule in the "default" namespace containing a host "reviews" will be
   * interpreted as "reviews.default.svc.cluster.local", irrespective of
   * the actual namespace associated with the reviews service. _To avoid
   * potential misconfigurations, it is recommended to always use fully
   * qualified domain names over short names._
   * The hosts field applies to both HTTP and TCP services. Service inside
   * the mesh, i.e., those found in the service registry, must always be
   * referred to using their alphanumeric names. IP addresses are allowed
   * only for services defined via the Gateway.
   * *Note*: It must be empty for a delegate VirtualService.
   * </pre>
   *
   * <code>repeated string hosts = 1;</code>
   * @param index The index of the element to return.
   * @return The hosts at the given index.
   */
  java.lang.String getHosts(int index);
  /**
   * <pre>
   * The destination hosts to which traffic is being sent. Could
   * be a DNS name with wildcard prefix or an IP address.  Depending on the
   * platform, short-names can also be used instead of a FQDN (i.e. has no
   * dots in the name). In such a scenario, the FQDN of the host would be
   * derived based on the underlying platform.
   * A single VirtualService can be used to describe all the traffic
   * properties of the corresponding hosts, including those for multiple
   * HTTP and TCP ports. Alternatively, the traffic properties of a host
   * can be defined using more than one VirtualService, with certain
   * caveats. Refer to the
   * [Operations Guide](https://istio.io/docs/ops/best-practices/traffic-management/#split-virtual-services)
   * for details.
   * *Note for Kubernetes users*: When short names are used (e.g. "reviews"
   * instead of "reviews.default.svc.cluster.local"), Istio will interpret
   * the short name based on the namespace of the rule, not the service. A
   * rule in the "default" namespace containing a host "reviews" will be
   * interpreted as "reviews.default.svc.cluster.local", irrespective of
   * the actual namespace associated with the reviews service. _To avoid
   * potential misconfigurations, it is recommended to always use fully
   * qualified domain names over short names._
   * The hosts field applies to both HTTP and TCP services. Service inside
   * the mesh, i.e., those found in the service registry, must always be
   * referred to using their alphanumeric names. IP addresses are allowed
   * only for services defined via the Gateway.
   * *Note*: It must be empty for a delegate VirtualService.
   * </pre>
   *
   * <code>repeated string hosts = 1;</code>
   * @param index The index of the value to return.
   * @return The bytes of the hosts at the given index.
   */
  com.google.protobuf.ByteString
      getHostsBytes(int index);

  /**
   * <pre>
   * The names of gateways and sidecars that should apply these routes.
   * Gateways in other namespaces may be referred to by
   * `&lt;gateway namespace&gt;/&lt;gateway name&gt;`; specifying a gateway with no
   * namespace qualifier is the same as specifying the VirtualService's
   * namespace. A single VirtualService is used for sidecars inside the mesh as
   * well as for one or more gateways. The selection condition imposed by this
   * field can be overridden using the source field in the match conditions
   * of protocol-specific routes. The reserved word `mesh` is used to imply
   * all the sidecars in the mesh. When this field is omitted, the default
   * gateway (`mesh`) will be used, which would apply the rule to all
   * sidecars in the mesh. If a list of gateway names is provided, the
   * rules will apply only to the gateways. To apply the rules to both
   * gateways and sidecars, specify `mesh` as one of the gateway names.
   * </pre>
   *
   * <code>repeated string gateways = 2;</code>
   * @return A list containing the gateways.
   */
  java.util.List<java.lang.String>
      getGatewaysList();
  /**
   * <pre>
   * The names of gateways and sidecars that should apply these routes.
   * Gateways in other namespaces may be referred to by
   * `&lt;gateway namespace&gt;/&lt;gateway name&gt;`; specifying a gateway with no
   * namespace qualifier is the same as specifying the VirtualService's
   * namespace. A single VirtualService is used for sidecars inside the mesh as
   * well as for one or more gateways. The selection condition imposed by this
   * field can be overridden using the source field in the match conditions
   * of protocol-specific routes. The reserved word `mesh` is used to imply
   * all the sidecars in the mesh. When this field is omitted, the default
   * gateway (`mesh`) will be used, which would apply the rule to all
   * sidecars in the mesh. If a list of gateway names is provided, the
   * rules will apply only to the gateways. To apply the rules to both
   * gateways and sidecars, specify `mesh` as one of the gateway names.
   * </pre>
   *
   * <code>repeated string gateways = 2;</code>
   * @return The count of gateways.
   */
  int getGatewaysCount();
  /**
   * <pre>
   * The names of gateways and sidecars that should apply these routes.
   * Gateways in other namespaces may be referred to by
   * `&lt;gateway namespace&gt;/&lt;gateway name&gt;`; specifying a gateway with no
   * namespace qualifier is the same as specifying the VirtualService's
   * namespace. A single VirtualService is used for sidecars inside the mesh as
   * well as for one or more gateways. The selection condition imposed by this
   * field can be overridden using the source field in the match conditions
   * of protocol-specific routes. The reserved word `mesh` is used to imply
   * all the sidecars in the mesh. When this field is omitted, the default
   * gateway (`mesh`) will be used, which would apply the rule to all
   * sidecars in the mesh. If a list of gateway names is provided, the
   * rules will apply only to the gateways. To apply the rules to both
   * gateways and sidecars, specify `mesh` as one of the gateway names.
   * </pre>
   *
   * <code>repeated string gateways = 2;</code>
   * @param index The index of the element to return.
   * @return The gateways at the given index.
   */
  java.lang.String getGateways(int index);
  /**
   * <pre>
   * The names of gateways and sidecars that should apply these routes.
   * Gateways in other namespaces may be referred to by
   * `&lt;gateway namespace&gt;/&lt;gateway name&gt;`; specifying a gateway with no
   * namespace qualifier is the same as specifying the VirtualService's
   * namespace. A single VirtualService is used for sidecars inside the mesh as
   * well as for one or more gateways. The selection condition imposed by this
   * field can be overridden using the source field in the match conditions
   * of protocol-specific routes. The reserved word `mesh` is used to imply
   * all the sidecars in the mesh. When this field is omitted, the default
   * gateway (`mesh`) will be used, which would apply the rule to all
   * sidecars in the mesh. If a list of gateway names is provided, the
   * rules will apply only to the gateways. To apply the rules to both
   * gateways and sidecars, specify `mesh` as one of the gateway names.
   * </pre>
   *
   * <code>repeated string gateways = 2;</code>
   * @param index The index of the value to return.
   * @return The bytes of the gateways at the given index.
   */
  com.google.protobuf.ByteString
      getGatewaysBytes(int index);

  /**
   * <pre>
   * An ordered list of route rules for HTTP traffic. HTTP routes will be
   * applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   * ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
   * entry ports using HTTP/HTTP2/GRPC protocols.  The first rule matching
   * an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.HTTPRoute http = 3;</code>
   */
  java.util.List<io.ourea.adapter.model.istio.HTTPRoute> 
      getHttpList();
  /**
   * <pre>
   * An ordered list of route rules for HTTP traffic. HTTP routes will be
   * applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   * ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
   * entry ports using HTTP/HTTP2/GRPC protocols.  The first rule matching
   * an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.HTTPRoute http = 3;</code>
   */
  io.ourea.adapter.model.istio.HTTPRoute getHttp(int index);
  /**
   * <pre>
   * An ordered list of route rules for HTTP traffic. HTTP routes will be
   * applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   * ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
   * entry ports using HTTP/HTTP2/GRPC protocols.  The first rule matching
   * an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.HTTPRoute http = 3;</code>
   */
  int getHttpCount();
  /**
   * <pre>
   * An ordered list of route rules for HTTP traffic. HTTP routes will be
   * applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   * ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
   * entry ports using HTTP/HTTP2/GRPC protocols.  The first rule matching
   * an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.HTTPRoute http = 3;</code>
   */
  java.util.List<? extends io.ourea.adapter.model.istio.HTTPRouteOrBuilder> 
      getHttpOrBuilderList();
  /**
   * <pre>
   * An ordered list of route rules for HTTP traffic. HTTP routes will be
   * applied to platform service ports named 'http-*'/'http2-*'/'grpc-*', gateway
   * ports with protocol HTTP/HTTP2/GRPC/ TLS-terminated-HTTPS and service
   * entry ports using HTTP/HTTP2/GRPC protocols.  The first rule matching
   * an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.HTTPRoute http = 3;</code>
   */
  io.ourea.adapter.model.istio.HTTPRouteOrBuilder getHttpOrBuilder(
      int index);

  /**
   * <pre>
   * An ordered list of route rule for non-terminated TLS &amp; HTTPS
   * traffic. Routing is typically performed using the SNI value presented
   * by the ClientHello message. TLS routes will be applied to platform
   * service ports named 'https-*', 'tls-*', unterminated gateway ports using
   * HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service
   * entry ports using HTTPS/TLS protocols.  The first rule matching an
   * incoming request is used.  NOTE: Traffic 'https-*' or 'tls-*' ports
   * without associated virtual service will be treated as opaque TCP
   * traffic.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TLSRoute tls = 5;</code>
   */
  java.util.List<io.ourea.adapter.model.istio.TLSRoute> 
      getTlsList();
  /**
   * <pre>
   * An ordered list of route rule for non-terminated TLS &amp; HTTPS
   * traffic. Routing is typically performed using the SNI value presented
   * by the ClientHello message. TLS routes will be applied to platform
   * service ports named 'https-*', 'tls-*', unterminated gateway ports using
   * HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service
   * entry ports using HTTPS/TLS protocols.  The first rule matching an
   * incoming request is used.  NOTE: Traffic 'https-*' or 'tls-*' ports
   * without associated virtual service will be treated as opaque TCP
   * traffic.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TLSRoute tls = 5;</code>
   */
  io.ourea.adapter.model.istio.TLSRoute getTls(int index);
  /**
   * <pre>
   * An ordered list of route rule for non-terminated TLS &amp; HTTPS
   * traffic. Routing is typically performed using the SNI value presented
   * by the ClientHello message. TLS routes will be applied to platform
   * service ports named 'https-*', 'tls-*', unterminated gateway ports using
   * HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service
   * entry ports using HTTPS/TLS protocols.  The first rule matching an
   * incoming request is used.  NOTE: Traffic 'https-*' or 'tls-*' ports
   * without associated virtual service will be treated as opaque TCP
   * traffic.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TLSRoute tls = 5;</code>
   */
  int getTlsCount();
  /**
   * <pre>
   * An ordered list of route rule for non-terminated TLS &amp; HTTPS
   * traffic. Routing is typically performed using the SNI value presented
   * by the ClientHello message. TLS routes will be applied to platform
   * service ports named 'https-*', 'tls-*', unterminated gateway ports using
   * HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service
   * entry ports using HTTPS/TLS protocols.  The first rule matching an
   * incoming request is used.  NOTE: Traffic 'https-*' or 'tls-*' ports
   * without associated virtual service will be treated as opaque TCP
   * traffic.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TLSRoute tls = 5;</code>
   */
  java.util.List<? extends io.ourea.adapter.model.istio.TLSRouteOrBuilder> 
      getTlsOrBuilderList();
  /**
   * <pre>
   * An ordered list of route rule for non-terminated TLS &amp; HTTPS
   * traffic. Routing is typically performed using the SNI value presented
   * by the ClientHello message. TLS routes will be applied to platform
   * service ports named 'https-*', 'tls-*', unterminated gateway ports using
   * HTTPS/TLS protocols (i.e. with "passthrough" TLS mode) and service
   * entry ports using HTTPS/TLS protocols.  The first rule matching an
   * incoming request is used.  NOTE: Traffic 'https-*' or 'tls-*' ports
   * without associated virtual service will be treated as opaque TCP
   * traffic.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TLSRoute tls = 5;</code>
   */
  io.ourea.adapter.model.istio.TLSRouteOrBuilder getTlsOrBuilder(
      int index);

  /**
   * <pre>
   * An ordered list of route rules for opaque TCP traffic. TCP routes will
   * be applied to any port that is not a HTTP or TLS port. The first rule
   * matching an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TCPRoute tcp = 4;</code>
   */
  java.util.List<io.ourea.adapter.model.istio.TCPRoute> 
      getTcpList();
  /**
   * <pre>
   * An ordered list of route rules for opaque TCP traffic. TCP routes will
   * be applied to any port that is not a HTTP or TLS port. The first rule
   * matching an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TCPRoute tcp = 4;</code>
   */
  io.ourea.adapter.model.istio.TCPRoute getTcp(int index);
  /**
   * <pre>
   * An ordered list of route rules for opaque TCP traffic. TCP routes will
   * be applied to any port that is not a HTTP or TLS port. The first rule
   * matching an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TCPRoute tcp = 4;</code>
   */
  int getTcpCount();
  /**
   * <pre>
   * An ordered list of route rules for opaque TCP traffic. TCP routes will
   * be applied to any port that is not a HTTP or TLS port. The first rule
   * matching an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TCPRoute tcp = 4;</code>
   */
  java.util.List<? extends io.ourea.adapter.model.istio.TCPRouteOrBuilder> 
      getTcpOrBuilderList();
  /**
   * <pre>
   * An ordered list of route rules for opaque TCP traffic. TCP routes will
   * be applied to any port that is not a HTTP or TLS port. The first rule
   * matching an incoming request is used.
   * </pre>
   *
   * <code>repeated .istio.networking.v1alpha3.TCPRoute tcp = 4;</code>
   */
  io.ourea.adapter.model.istio.TCPRouteOrBuilder getTcpOrBuilder(
      int index);

  /**
   * <pre>
   * A list of namespaces to which this virtual service is exported. Exporting a
   * virtual service allows it to be used by sidecars and gateways defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of virtual services
   * across namespace boundaries.
   * If no namespaces are specified then the virtual service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the virtual service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 6;</code>
   * @return A list containing the exportTo.
   */
  java.util.List<java.lang.String>
      getExportToList();
  /**
   * <pre>
   * A list of namespaces to which this virtual service is exported. Exporting a
   * virtual service allows it to be used by sidecars and gateways defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of virtual services
   * across namespace boundaries.
   * If no namespaces are specified then the virtual service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the virtual service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 6;</code>
   * @return The count of exportTo.
   */
  int getExportToCount();
  /**
   * <pre>
   * A list of namespaces to which this virtual service is exported. Exporting a
   * virtual service allows it to be used by sidecars and gateways defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of virtual services
   * across namespace boundaries.
   * If no namespaces are specified then the virtual service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the virtual service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 6;</code>
   * @param index The index of the element to return.
   * @return The exportTo at the given index.
   */
  java.lang.String getExportTo(int index);
  /**
   * <pre>
   * A list of namespaces to which this virtual service is exported. Exporting a
   * virtual service allows it to be used by sidecars and gateways defined in
   * other namespaces. This feature provides a mechanism for service owners
   * and mesh administrators to control the visibility of virtual services
   * across namespace boundaries.
   * If no namespaces are specified then the virtual service is exported to all
   * namespaces by default.
   * The value "." is reserved and defines an export to the same namespace that
   * the virtual service is declared in. Similarly the value "*" is reserved and
   * defines an export to all namespaces.
   * NOTE: in the current release, the `exportTo` value is restricted to
   * "." or "*" (i.e., the current namespace or all namespaces).
   * </pre>
   *
   * <code>repeated string export_to = 6;</code>
   * @param index The index of the value to return.
   * @return The bytes of the exportTo at the given index.
   */
  com.google.protobuf.ByteString
      getExportToBytes(int index);
}
